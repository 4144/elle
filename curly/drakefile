import os

import drake
import drake.cxx
import drake.cxx.boost
import drake.valgrind

config = None
lib_static = None
lib_dynamic = None
library = None

lib_asio_static = None
lib_asio_dynamic = None
library_asio = None

rule_build = None
rule_check = None
rule_install = None
rule_tests = None

def configure(curl_config,
              curl_lib,
              cxx_toolkit = None,
              cxx_config = None,
              boost = None,
              elle = None,
              reactor = None,
              prefix = '/usr',
              valgrind = None):

  global config
  global lib_static, lib_dynamic, library
  global library_asio, lib_sched_static, library_sched
  global lib_asio_dynamic, lib_asio_static, library_asio
  global library_curl
  global rule_build, rule_install

  with open(str(drake.path_source('../drake-utils.py')), 'r') as f:
    exec(f.read(), globals(), globals())

  # Toolkit
  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()

  # Boost
  boost = boost or drake.cxx.boost.Boost()


  elle = elle or drake.include('../elle')
  elle_lib = drake.copy(elle.library, 'lib', strip_prefix = True)

  # Global Configuration
  config = drake.cxx.Config()
  config.standard = drake.cxx.Config.cxx_11
  config.add_local_include_path('.')
  config.lib_path('lib')
  config += curl_config
  config += boost.config()
  if isinstance(curl_lib, drake.cxx.StaticLib):
    config.define('CURL_STATICLIB', '1')

  # Local Configuration
  cxx_config = drake.cxx.Config(cxx_config or drake.cxx.Config())
  cxx_config.standard = drake.cxx.Config.cxx_11
  cxx_config += config
  cxx_config += elle.config
  cxx_config.lib_path_runtime('.')
  cxx_config += boost.config_system()

  # Libraries
  curl_lib = drake.copy(curl_lib, 'lib', strip_prefix = True)

  # Sources
  sources = drake.nodes(
    'curly/curly.cc',
    'curly/curly.hh',
    'curly/curly.hxx',
    'curly/exceptions.cc',
    'curly/exceptions.hh',
  )

  lib_static = drake.cxx.StaticLib('lib/curly',
                                   sources + [curl_lib],
                                   cxx_toolkit, cxx_config)
  lib_dynamic = drake.cxx.DynLib('lib/curly',
                                 sources + [curl_lib],
                                 cxx_toolkit, cxx_config)

  if cxx_toolkit.os == drake.os.windows:
    library = lib_static
  else:
    library = lib_dynamic

  # Local Configuration Asio
  cxx_config_asio = drake.cxx.Config(cxx_config)
  cxx_config_asio += cxx_config
  cxx_config_asio += boost.config()
  cxx_config_asio.lib('curly')

  source_asio = drake.nodes(
    'curly/asio_request.cc',
    'curly/asio_request.hh',
    'curly/curly_service.cc',
    'curly/curly_service.hh',
    'curly/curly_service.hxx',
  )


  lib_asio_static = drake.cxx.StaticLib(
    'lib/curly_asio',
    source_asio + [library],
    cxx_toolkit,
    cxx_config_asio
  )

  lib_asio_dynamic = drake.cxx.DynLib(
    'lib/curly_asio',
    source_asio + [library],
    cxx_toolkit,
    cxx_config_asio
  )

  # Local Configuration reactor
  cxx_config_sched = drake.cxx.Config(cxx_config_asio)
  cxx_config_sched += cxx_config_asio
  cxx_config_sched += reactor.config
  reactor_lib = drake.copy(reactor.library, 'lib',
                           strip_prefix = True)

  source_sched = drake.nodes(
      'curly/curly_sched.cc',
      'curly/curly_sched.hh',
  )

  lib_sched_static = \
    drake.cxx.StaticLib('lib/curly_sched',
                        source_sched + [reactor.library, lib_asio_static],
                        cxx_toolkit, cxx_config_sched)
  lib_sched_dynamic = \
    drake.cxx.DynLib('lib/curly_sched',
                     source_sched + [reactor.lib_dynamic, lib_asio_dynamic],
                     cxx_toolkit, cxx_config_sched)

  # Build
  rule_build = drake.Rule('build')
  rule_build << lib_static
  rule_build << lib_asio_static
  rule_build << lib_sched_static
  if cxx_toolkit.os != drake.os.windows:
    rule_build << lib_dynamic
    rule_build << lib_asio_dynamic
    rule_build << lib_sched_dynamic
    library_asio = lib_asio_dynamic
    library_sched = lib_sched_dynamic
  else:
    library_asio = lib_asio_static
    library_sched = lib_sched_static


  class unit_test:
      def __init__(self, sources, args = None):
          self.sources = sources
          if isinstance(args, (list, tuple)):
              self.args = args
          elif args:
              self.args = [args]
          else:
              self.args = None

  # Tests
  tests_sched = [
      unit_test('tests/sched.cc'),
      unit_test('tests/test.cc'),
  ]

  global rule_check, rule_tests
  rule_check = drake.TestSuite('check')
  rule_tests = drake.Rule('tests')
  for test in tests_sched:
    cxx_config_tests = drake.cxx.Config(cxx_config)
    cxx_config_tests += reactor.config
    cxx_config_tests.lib_path_runtime('../lib')
    cxx_config_tests += boost.config_test()
    cxx_config_tests += boost.config_signals()
    cxx_config_tests += boost.config_thread()
    name, ext = os.path.splitext(os.path.basename(test.sources))
    bin_path = drake.Path('tests/%s' % name)
    bin = drake.cxx.Executable(
      bin_path,
      drake.nodes(test.sources) +
      [
        library,
        library_asio,
        library_sched,
        reactor_lib,
        elle_lib,
        curl_lib,
        reactor.library_coroutine,
      ],
      cxx_toolkit,
      cxx_config_tests
    )
    rule_tests << bin
    if valgrind is not None:
      runner = drake.valgrind.ValgrindRunner(exe = bin,
                                             args = test.args,
                                             valgrind = valgrind)
    else:
      runner = drake.Runner(exe = bin, args = test.args)
    runner.reporting = drake.Runner.Reporting.on_failure
    rule_check << runner.status

  # Install
  rule_install = drake.Rule('install')
  prefix = drake.Path(prefix)
  rule_install << drake.install(lib_dynamic, prefix)
  rule_install << drake.install(lib_static, prefix)
  rule_install << drake.install(
    list(filter(lambda n: isinstance(n, drake.cxx.Header), sources)),
    prefix / 'include', 'sources')
