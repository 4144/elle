import os

import drake
import drake.cxx
import drake.cxx.boost
import drake.valgrind

config = None
lib_static = None
lib_dynamic = None
library = None

lib_asio_static = None
lib_asio_dynamic = None
library_asio = None

lib_sched_static = None
lib_sched_dynamic = None
library_sched = None

rule_build = None
rule_check = None
rule_install = None
rule_tests = None

def configure(cxx_toolkit = None,
              cxx_config = None,
              boost = None,
              elle = None,
              curl = None,
              reactor = None,
              openssl = None,
              openssl_libs = None,
              prefix = '/usr',
              valgrind = None):

  global config
  global lib_static, lib_dynamic, library
  global library_asio, lib_sched_static, library_sched
  global lib_asio_dynamic, lib_asio_static, library_asio
  global rule_build, rule_install

  with open(str(drake.path_source('../drake-utils.py')), 'r') as f:
    exec(f.read(), globals(), globals())

  # Toolkit
  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()

  # Boost
  boost = boost or drake.cxx.boost.Boost()

  # Curl
  curl_basename = 'curl-7.32.0'
  curl_tarball = drake.node('curl/%s.tar.gz' % curl_basename)
  curl_root = drake.Path('curl') / curl_basename
  curl_url = 'http://curl.haxx.se/download/%s.tar.gz' % curl_basename
  drake.HTTPDownload(curl_url, curl_tarball,
                     fingerprint = 'f77cf3cb59cf2bfe686b80338323fd40')
  drake.TarballExtractor(
    curl_tarball,
    targets = ['%s/%s' % (curl_basename, f) for f in (
      'configure',
      'include/curl/typecheck-gcc.h',
      'include/curl/stdcheaders.h',
      'include/curl/easy.h',
      'include/curl/mprintf.h',
      'include/curl/curl.h',
      'include/curl/curlver.h',
      'include/curl/multi.h',
      'include/curl/curlbuild.h',
      'include/curl/curlrules.h',
    )]
  )
  curl_configure = drake.node(curl_root / 'configure')
  from drake.cxx import DynLib
  if cxx_toolkit.os is drake.os.linux:
    curl_lib = DynLib('curl/lib/libcurl.so.4', lib_name = 'curl')
  else:
    curl_lib = DynLib('curl/lib/libcurl.4.dylib', lib_name = 'curl')
  openssl_libs = drake.copy(openssl_libs, 'lib',
                            openssl_libs[0].name().dirname())
  # print(openssl_libs[0].path())
  # print(openssl_libs[0].path().dirname())
  openssl_prefix = drake.path_root() / openssl
  openssl_configure_args = [
    '--prefix=%s/%s' % (os.getcwd(), drake.path_build('curl')),
    '--with-ssl=%s' % openssl_prefix,
    '--enable-hidden-symbols',
    '--enable-optimize',
    '--enable-warnings',
    '--enable-threaded-resolver',
    '--disable-static',
    '--disable-ldap',
    '--disable-ldaps',
    '--disable-rtmp',
    '--disable-sspi',
    '--disable-ssh',
    '--disable-rtsp',
    '--with-gssapi',
    '--without-libidn',
  ]
  if cxx_toolkit.os is drake.os.linux:
    # So curl links its curl binary with the right SSL.
    openssl_configure_args.append(
      'LDFLAGS=-Wl,-rpath-link,%s' % (openssl_prefix / 'lib'))
  GNUBuilder(cxx_toolkit,
             configure = curl_configure,
             targets = [curl_lib],
             configure_args = openssl_configure_args,
             sources = openssl_libs)
  curl_lib = drake.copy(curl_lib, '.', 'curl')
  curl_config = drake.cxx.Config()
  curl_config.add_local_include_path(curl_root / 'include')

  elle = elle or drake.include('../elle')
  elle_lib = drake.copy(elle.lib_dynamic, 'lib',
                        elle.lib_dynamic.name().dirname())

  # Global Configuration
  config = drake.cxx.Config()
  config.standard = drake.cxx.Config.cxx_11
  config.add_local_include_path('.')
  config.lib_path('lib')
  config += curl_config
  config += boost.config()

  # Local Configuration
  cxx_config = drake.cxx.Config(cxx_config or drake.cxx.Config())
  cxx_config.standard = drake.cxx.Config.cxx_11
  cxx_config += config
  cxx_config += elle.config
  cxx_config.lib_path_runtime('.')
  cxx_config += boost.config_system()

  # http
#http_path = drake.Node('scripts/http.py')

  # Sources
  sources = drake.nodes(
    'curly/curly.cc',
    'curly/curly.hh',
    'curly/curly.hxx',
    'curly/exceptions.cc',
    'curly/exceptions.hh',
  )

  lib_static = drake.cxx.StaticLib('lib/curly',
                                   sources + [curl_lib],
                                   cxx_toolkit, cxx_config)
  lib_dynamic = drake.cxx.DynLib('lib/curly',
                                 sources + [curl_lib],
                                 cxx_toolkit, cxx_config)

  if cxx_toolkit.os == drake.os.windows:
    library = lib_static
  else:
    library = lib_dynamic

  # Local Configuration Asio
  cxx_config_asio = drake.cxx.Config(cxx_config)
  cxx_config_asio += cxx_config
  cxx_config_asio += boost.config()
  cxx_config_asio.lib('curly')

  source_asio = drake.nodes(
    'curly/asio_request.cc',
    'curly/asio_request.hh',
    'curly/curly_service.cc',
    'curly/curly_service.hh',
    'curly/curly_service.hxx',
  )


  lib_asio_static = drake.cxx.StaticLib(
    'lib/curly_asio',
    source_asio + [library],
    cxx_toolkit,
    cxx_config_asio
  )

  lib_asio_dynamic = drake.cxx.DynLib(
    'lib/curly_asio',
    source_asio + [library],
    cxx_toolkit,
    cxx_config_asio
  )

  # Local Configuration reactor
  cxx_config_sched = drake.cxx.Config(cxx_config_asio)
  cxx_config_sched += cxx_config_asio
  cxx_config_sched += reactor.config
  reactor_lib = drake.copy(reactor.library, 'lib',
                           reactor.library.name().dirname())

  source_sched = drake.nodes(
      'curly/curly_sched.cc',
      'curly/curly_sched.hh',
  )

  lib_sched_static = \
    drake.cxx.StaticLib('lib/curly_sched',
                        source_sched + [reactor.library, lib_asio_static],
                        cxx_toolkit, cxx_config_sched)
  lib_sched_dynamic = \
    drake.cxx.DynLib('lib/curly_sched',
                     source_sched + [reactor.lib_dynamic, lib_asio_dynamic],
                     cxx_toolkit, cxx_config_sched)

  # Build
  rule_build = drake.Rule('build')
  rule_build << lib_static
  rule_build << lib_asio_static
  rule_build << lib_sched_static
  if cxx_toolkit.os != drake.os.windows:
    rule_build << lib_dynamic
    rule_build << lib_asio_dynamic
    rule_build << lib_sched_dynamic
    library_asio = lib_asio_dynamic
    library_sched = lib_sched_dynamic
  else:
    library_asio = lib_asio_static
    library_sched = lib_sched_static


  class unit_test:
      def __init__(self, sources, args = None):
          self.sources = sources
          if isinstance(args, (list, tuple)):
              self.args = args
          elif args:
              self.args = [args]
          else:
              self.args = None

  # Tests
  tests_sched = [
      unit_test('tests/sched.cc'),
      unit_test('tests/test.cc'),
  ]

  global rule_check, rule_tests
  rule_check = drake.TestSuite('check')
  rule_tests = drake.Rule('tests')
  for test in tests_sched:
    cxx_config_tests = drake.cxx.Config(cxx_config)
    cxx_config_tests += reactor.config
    cxx_config_tests.lib_path_runtime('../lib')
    cxx_config_tests += boost.config_test()
    name, ext = os.path.splitext(os.path.basename(test.sources))
    bin_path = drake.Path('tests/%s' % name)
    bin = drake.cxx.Executable(bin_path,
                               drake.nodes(test.sources) +
                               [library,
                                library_asio,
                                library_sched,
                                reactor_lib, elle_lib,
                                curl_lib],
                               cxx_toolkit, cxx_config_tests)
    rule_tests << bin
    if valgrind is not None:
      runner = drake.valgrind.ValgrindRunner(exe = bin,
                                             args = test.args,
                                             valgrind = valgrind)
    else:
      runner = drake.Runner(exe = bin, args = test.args)
    runner.reporting = drake.Runner.Reporting.on_failure
    rule_check << runner.status

  # Install
  rule_install = drake.Rule('install')
  prefix = drake.Path(prefix)
  rule_install << drake.install(lib_dynamic, prefix)
  rule_install << drake.install(lib_static, prefix)
  rule_install << drake.install(
    list(filter(lambda n: isinstance(n, drake.cxx.Header), sources)),
    prefix / 'include', 'sources')
