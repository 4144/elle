o quand donnees modifiees et donc new token -> update Rights
o faire un wall/Path pour tester les paths
o dans components/Access, on peut aller plus loin car un grant pourrait passer un user de vassal a delegate par exemple!
o mettre un bit a 1 dans Readdir lorsqu'on a atteint la fin pour eviter une autre requete inutile! ou mieux l'index de fin!
o pour eviter les trucs de merde on pourrait, dans Context::Create verifier qu'il n'existe pas deja un contexte pour cet object, si oui
  on refuse!
o lorsqu'on destroy un objet d'un directory, la question c'est: doit on avoir le droit sur le rep et sur l'objet ou que sur le rep comme
  sous UNIX.
  -> vue unique: il faut que ce soit coherent donc qui dit delete objet dit update directory parent donc il faut avoir le droit de
     detruire objet + update parent
  -> vue propre: coherence non requise donc qui dit delete objet dit update directory et c'est tout.

  => peu importe le cas, il est fort probable que des blocs se retrouvent orphan et cela pour pleins de raisons: non atomicite
     des operations de delete. un client pourrait commencer a delete puis crash. et unlike un FS classique, rien ne garantit que
     le client va redemarrer. donc on est sur d'avoir des orphans. donc il faut forcement un systeme de garbage collecting comme
     par exemple via un system d'aging: il faut explicitement rafraichir les blocs dont on est proprio.

  => donc la destruction des blocs orphan est resolu. cela dit la coherence de la view c'est autre chose.
     -> vue unique (coherence forte): creation doit etre atomique (encore une fois c'est impossible et un client pourrait ne
        pas suivre le protocole i.e insertion donnees avant objet, donc encore une fois impossible de garantir un telle view).

  =>>> bon puisqu'on a pas d'atomicite (creation, modification, deletion), on ne peut pas garantir la coherence. de ce fait
       avoir une vue unique n'a pas vraiment de sens puisqu'elle souffira des meme

  (bien sur on peut avoir de la coherence si (i) on locke les noeuds de stockage avant chaque operation de modification
   (ii) les clients suivent le protocole. malheureusement la couche stockage ne considere que l'atomicite d'une operation
   comme l'insertion par exemple et non les relations entre differents blocs: ce qui forme ce que nous nommons la coherence:
   par exemple un repertoire qui reference un objet. si cet objet est detruit le repertoire est incoherent, il doit donc
   etre modifie mais au niveau stockage, rien ne permet de garantir cela)
o il faudrait surement faire des fichiers de configurations ou du code de configuration general a tous les programmes.
  par exemple le path pour ~/.infinit/ se retrouve partout :(
o faire en sorte que les contexts IDLE soient detruits car ca risque d'arriver beaucoup. la question etant: comment
  savoir si il est mort ou pas :(
o si un noeud refuse de stocker des donnees, on demande a Infinit CA qui lui sait combien le user a accepte de contribuer
  et combien il consomme (le client regulierement informe le CA de la quantite utilisee et refuse de se lancer si il
  n'y a pas assez de place)
o dans Hole::Get, ne pas virer Factory car dans 8debug on s'en sert puisque lorsque l'on dump un bloque, on ne peut
  pas savoir son type avant de l'avoir chopper et en fait on veut pas savoir son type: on s'en branle!
o revoir les "Accord control", et les appliquer correctement et changer le nom!
o avec une stack de 32K pour les fibres, copier le kernel linux plante! investiguer!
o compilation kernel linux plante mais la le systeme est trop lent pour debugger, ca prend des heures
  il semble que le directory racine soit ouvert (Opendir) vers les identifier 33000, et il est utilise
  pour lire le repertoire quand on est aux identifiers 130000, donc forcement le repertoire a ete modifie
  depuis et donc l'adresse du contenu n'existe plus.
  peut etre qu'un flush a ete appele ou je ne sais pas...
o ajouter un identifier 16-bit pour le reseau pour que les blocs ne rentrent pas en collision
o ajouter la gestion des liens dans Path::Resolve() -> fournir Path::Resolve dans wall
o regarder si c'est normal d'avoir des offsets out of bound
o passer PIG en threade
o si jamais on a trop de perf a cause des copies, introduire un operator genre >> pour signifier le
  move!

--

o ajouter les options a 8user, 8group, 8network (?hub?)
o inclure component dans l'addresse (HOLE)
o mettre les options dans Agent et aussi dans PIG en donnant les bonnes options a FUSE donc nom du FS etc.
o faire que Block soit Fileable comme ca on est tranquil
o faire nouveau repo opur lune

o faire que Associat utilise Settings
o l'appplication qui se connecte a Etoile en specifiant le reseau doit fournir le passport pour ce
  reseau. Etoile verifie que le passport correspond a l'identite du user en cours. puis tout est
  passe a hole, via un Hole::Join, qui lui alloue le necessaire, se connecte au reseau.
  NON il faudrait que ce soit Hole qui verifie tout ca!

--

user = name
       - website user identified by its unique user name
       - has a certificate signed by the CA
       - has a set of passports granting her access to a set of universes

certificate = (user name, pair) signed by CA
              - grants the user an Infinit identity

memento = (name, root block address, network address)
          - identifies a universe through its name and the root directory address
          - the network address(es) is here to bootstrap, i.e join the universe

passport = (pair encrypted by user's pair, memento) signed by CA
          - since the pair for this universe is encrypted, the
            user can decrypt it with its pair and therefore has
            to remember a single pass and to store a single certificate

user/
  mycure/
    mycure.id
    passports/
      kapoue.pprt
universe/
  kapoue/
    kapoue.mmt
    reserve/
    hole/
infinit.auth
