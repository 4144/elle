import drake
import drake.cxx
import drake.cxx.boost

config = None
lib_static = None
lib_dynamic = None

rule_build = None
rule_check = None
rule_install = None
rule_tests = None

asio_udt_lib = None

def configure(cxx_toolkit = None,
              cxx_config = None,
              boost = None,
              elle = None,
              stuntman = None,
              prefix = '/usr',
              valgrind = None):

  global asio_udt_lib
  global config, lib_static, lib_dynamic
  global rule_build, rule_install

  # Public C++ configuration
  config = drake.cxx.Config()
  config.add_local_include_path('src')
  config.standard = drake.cxx.Config.cxx_11
  config.lib_path('lib')

  # Local C++ configuration
  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()
  local_cxx_config = drake.cxx.Config(cxx_config)
  local_cxx_config.lib_path_runtime('.')

  # Boost
  boost = boost or drake.cxx.boost.Boost()
  local_cxx_config += boost.config()

  # Stuntman
  if stuntman is not None:
    local_cxx_config += stuntman.config()
    local_cxx_config.lib('stuncore')
    local_cxx_config.lib('stuncommon')
    local_cxx_config.lib('crypto')
    config.define('REACTOR_HAVE_STUN')

  # Elle
  elle = elle or drake.include('../elle')
  local_cxx_config += elle.config
  elle_lib = drake.copy(elle.lib_dynamic, 'lib', elle.lib_dynamic.name().dirname())

  # UDT
  #asio_udt = drake.include('asio-udt', cxx_toolkit, cxx_config, boost = boost)
  #asio_udt_lib = drake.copy(asio_udt.library, '', 'asio-udt')
  #udt_lib = drake.copy(asio_udt.udt.library, '', 'asio-udt/udt')

  # Asio-FS
  # asio_fs = drake.include('asio-fs', cxx_toolkit, cxx_config, boost = boost)
  # asio_fs_lib = drake.copy(asio_fs.library_dynamic, '', 'asio-fs')
  # config += asio_fs.config

  local_cxx_config += config

  # Boost libraries
  local_cxx_config += boost.config_signals()
  local_cxx_config += boost.config_system()
  local_cxx_config += boost.config_thread()
  local_cxx_config.enable_debug_symbols()

  libcoroutine_sources = drake.nodes(
    'src/reactor/backend/coro_io/libcoroutine/asm.S',
    'src/reactor/backend/coro_io/libcoroutine/context.cc',
    'src/reactor/backend/coro_io/libcoroutine/coroutine.cc',
    'src/reactor/backend/coro_io/libcoroutine/coroutine.hh',
  )
  libcoroutine_cxx_config = drake.cxx.Config(local_cxx_config)
  libcoroutine_cxx_config.warnings.missing_declarations = None
  if valgrind is not None:
    libcoroutine_cxx_config.define('USE_VALGRIND')
  libcoroutine = drake.cxx.StaticLib('lib/coroutine',
                                     libcoroutine_sources,
                                     cxx_toolkit,
                                     libcoroutine_cxx_config)

  sources = drake.nodes(
    'src/reactor/Barrier.cc',
    'src/reactor/Barrier.hh',
    'src/reactor/Scope.cc',
    'src/reactor/Scope.hh',
    'src/reactor/asio.hh',
    'src/reactor/backend/coro_io/thread.cc',
    'src/reactor/backend/coro_io/thread.hh',
    'src/reactor/backend/pthread/pthread.cc',
    'src/reactor/backend/pthread/pthread.hh',
    'src/reactor/backend/thread.hh',
    'src/reactor/duration.cc',
    'src/reactor/duration.hh',
    'src/reactor/exception.cc',
    'src/reactor/exception.hh',
    # 'src/reactor/fs/File.hh',
    # 'src/reactor/fs/File.cc',
    'src/reactor/fsm/fwd.hh',
    'src/reactor/fsm/CatchTransition.cc',
    'src/reactor/fsm/CatchTransition.hh',
    'src/reactor/fsm/EndTransition.cc',
    'src/reactor/fsm/EndTransition.hh',
    'src/reactor/fsm/Machine.cc',
    'src/reactor/fsm/Machine.hh',
    'src/reactor/fsm/Machine.hxx',
    'src/reactor/fsm/State.cc',
    'src/reactor/fsm/State.hh',
    'src/reactor/fsm/Transition.cc',
    'src/reactor/fsm/Transition.hh',
    'src/reactor/fsm/WaitableTransition.cc',
    'src/reactor/fsm/WaitableTransition.hh',
    'src/reactor/fwd.hh',
    'src/reactor/lockable.cc',
    'src/reactor/lockable.hh',
    'src/reactor/logger.cc',
    'src/reactor/mutex.cc',
    'src/reactor/mutex.hh',
    'src/reactor/network/buffer.hh',
    'src/reactor/network/exception.cc',
    'src/reactor/network/exception.hh',
    'src/reactor/network/fwd.hh',
    'src/reactor/network/nat.cc',
    'src/reactor/network/nat.hh',
    'src/reactor/network/Protocol.cc',
    'src/reactor/network/Protocol.hh',
    'src/reactor/network/resolve.cc',
    'src/reactor/network/resolve.hh',
    'src/reactor/network/server.cc',
    'src/reactor/network/server.hh',
    'src/reactor/network/socket.cc',
    'src/reactor/network/socket.hh',
    'src/reactor/network/socket-operation.cc',
    'src/reactor/network/socket-operation.hh',
    'src/reactor/network/tcp-server.cc',
    'src/reactor/network/tcp-server.hh',
    'src/reactor/network/tcp-socket.cc',
    'src/reactor/network/tcp-socket.hh',
    'src/reactor/network/udp-socket.cc',
    'src/reactor/network/udp-socket.hh',
    # 'src/reactor/network/udt-rdv-server.cc',
    # 'src/reactor/network/udt-rdv-server.hh',
    # 'src/reactor/network/udt-server.cc',
    # 'src/reactor/network/udt-server.hh',
    # 'src/reactor/network/udt-socket.cc',
    # 'src/reactor/network/udt-socket.hh',
    'src/reactor/operation.cc',
    'src/reactor/operation.hh',
    'src/reactor/rw-mutex.cc',
    'src/reactor/rw-mutex.hh',
    'src/reactor/scheduler.cc',
    'src/reactor/scheduler.hh',
    'src/reactor/semaphore.cc',
    'src/reactor/semaphore.hh',
    'src/reactor/signal.cc',
    'src/reactor/signal.hh',
    'src/reactor/sleep.cc',
    'src/reactor/sleep.hh',
    'src/reactor/storage.cc',
    'src/reactor/storage.hh',
    'src/reactor/thread.cc',
    'src/reactor/thread.hh',
    'src/reactor/waitable.cc',
    'src/reactor/waitable.hh',
    )
  lib_static = drake.cxx.StaticLib('lib/reactor',
                                   sources + [libcoroutine],
                                   cxx_toolkit, local_cxx_config)
  lib_dynamic = drake.cxx.DynLib('lib/reactor',
                                 sources + [libcoroutine],
                                 cxx_toolkit, local_cxx_config)

  # Build
  rule_build = drake.Rule('build')
  rule_build << lib_static
  if cxx_toolkit.os != drake.os.windows:
    rule_build << lib_dynamic

  # Tests
  global rule_check, rule_tests
  rule_check = drake.TestSuite('check')
  rule_tests = drake.Rule('tests')

  tests = [
    'reactor/backend',
    'reactor/fsm',
    'reactor/logger',
    'reactor/network',
    'reactor/reactor',
    # 'reactor/file',
    ]

  if stuntman is not None:
    tests += [
      # XXX: Nat is disabled for now.
      #'reactor/nat'
      ]

  cxx_config_tests = drake.cxx.Config(local_cxx_config)
  cxx_config_tests += boost.config_filesystem(static = (cxx_toolkit.os is drake.os.macos))
  cxx_config_tests += boost.config_test()

  for test in tests:
    tests_config = drake.cxx.Config(cxx_config_tests)
    tests_config.lib_path_runtime('%s../lib' % ('../' * test.count('/')))
    if valgrind is not None:
      tests_config.define('VALGRIND')
    test = drake.cxx.Executable('tests/%s' % test,
                                drake.nodes('tests/%s.cc' % test) + [lib_dynamic, elle_lib],
                                cxx_toolkit, tests_config)
    rule_tests << test
    if valgrind is not None:
      runner = drake.valgrind.ValgrindRunner(exe = test,
                                             valgrind = valgrind)
    else:
      runner = drake.Runner(exe = test)
    runner.reporting = drake.Runner.Reporting.on_failure
    rule_check << runner.status

  # Install
  rule_install = drake.Rule('install')
  rule_install << drake.install(lib_dynamic, prefix)
  rule_install << drake.install(lib_static, prefix)
  rule_install << drake.install(
    list(filter(lambda n: isinstance(n, drake.cxx.Header), sources)),
    prefix / 'include', 'src')
