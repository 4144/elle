import drake
import drake.cxx
import drake.cxx.boost
import drake.templating
import sys
import os

config = None
lib_static = None
lib_dynamic = None
library = None
python_lib = None

library_coroutine = None

rule_build = None
rule_check = None
rule_install = None
rule_tests = None

asio_udt_lib = None

with open(str(drake.path_source('../drake-utils.py')), 'r') as f:
  exec(f.read(), globals(), globals())


def configure(curl_config,
              curl_lib,
              zlib_config,
              zlib_lib,
              cxx_toolkit,
              cxx_config,
              boost,
              openssl_config,
              openssl_lib_crypto,
              openssl_lib_ssl,
              python3 = None,
              elle = None,
              prefix = '/usr',
              valgrind = None,
              valgrind_tests = False,
              archs = [],
):

  global asio_udt_lib
  global config, lib_static, lib_dynamic, library
  global rule_build, rule_install
  global python_lib

  # Public C++ configuration
  config = drake.cxx.Config()
  config.add_local_include_path('src')
  config.standard = drake.cxx.Config.cxx_11
  config.lib_path('lib')

  # Local C++ configuration
  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()
  local_cxx_config = drake.cxx.Config(cxx_config)
  local_cxx_config += config
  local_cxx_config.lib_path_runtime('.')
  local_cxx_config.enable_debug_symbols()

  # Lib coroutine
  if cxx_toolkit.os is drake.os.windows:
    libcoroutine_sources = drake.nodes(
      'src/reactor/backend/coro_io/libcoroutine/asm.S',
      'src/reactor/backend/coro_io/libcoroutine/context.cc',
      'src/reactor/backend/coro_io/libcoroutine/coroutine.cc',
      'src/reactor/backend/coro_io/libcoroutine/coroutine.hh',
    )
    libcoroutine_cxx_config = drake.cxx.Config(local_cxx_config)
    libcoroutine_cxx_config.warnings.missing_declarations = None
    if valgrind is not None:
      libcoroutine_cxx_config.define('USE_VALGRIND')
    libcoroutine = drake.cxx.StaticLib('lib/reactor/coroutine',
                                       libcoroutine_sources,
                                       cxx_toolkit,
                                       libcoroutine_cxx_config)
    library_coroutine = libcoroutine

  # Boost
  boost = boost or drake.cxx.boost.Boost()
  local_cxx_config += boost.config()
  if cxx_toolkit.os in [drake.os.windows, drake.os.ios]:
    local_cxx_config += boost.config_signals(static = True)
    local_cxx_config += boost.config_system(static = True)
    local_cxx_config += boost.config_thread(static = True)
  else:
    local_cxx_config += boost.config_context(link = False)
    local_cxx_config += boost.config_signals(link = False)
    local_cxx_config.library_add(
      drake.copy(boost.context_dynamic, 'lib', strip_prefix = True))
    local_cxx_config.library_add(
      drake.copy(boost.signals_dynamic, 'lib', strip_prefix = True))
    local_cxx_config += boost.config_system(link = False)
    local_cxx_config.library_add(
      drake.copy(boost.system_dynamic, 'lib', strip_prefix = True))
    local_cxx_config += boost.config_thread(link = False)
    local_cxx_config.library_add(
      drake.copy(boost.thread_dynamic, 'lib', strip_prefix = True))

  # FUSE
  if cxx_toolkit.os is drake.os.linux:
    fuse_basename = 'fuse-2.9.3'
    fuse_url = \
      'http://downloads.sourceforge.net/' \
      'project/fuse/fuse-2.X/2.9.3/fuse-2.9.3.tar.gz'
    fuse_tarball = \
      drake.node('fuse/fuse-2.9.3.tar.gz')
    fuse_configure = \
      drake.node('fuse/fuse-2.9.3/configure')
    fuse_prefix = drake.path_build('fuse')
    fuse_prefix_absolute = drake.path_root() / fuse_prefix
    fuse_lib =  drake.cxx.DynLib('fuse/lib/libfuse.so.2')
    fuse_includes = drake.nodes(
      'fuse/include/fuse/cuse_lowlevel.h',
      'fuse/include/fuse/fuse_common_compat.h',
      'fuse/include/fuse/fuse_common.h',
      'fuse/include/fuse/fuse_compat.h',
      'fuse/include/fuse/fuse.h',
      'fuse/include/fuse/fuse_lowlevel_compat.h',
      'fuse/include/fuse/fuse_lowlevel.h',
      'fuse/include/fuse/fuse_opt.h'
      )
    drake.HTTPDownload(fuse_url, fuse_tarball,
                       fingerprint='33cae22ca50311446400daf8a6255c6a')
    drake.TarballExtractor(
      fuse_tarball,
      targets = ['%s/configure' % fuse_basename],
      patches = ((drake.node('fuse.patch'),1),),
      patch_dir = fuse_basename
    )
    GNUBuilder(
      cxx_toolkit,
      configure = fuse_configure,
      configure_args = [
      '--prefix=%s' % fuse_prefix_absolute,
      'CXX=%s' % cxx_toolkit.cxx,
      '--disable-util',
      '--disable-example',
      '--disable-static',
      '--enable-shared'
      ],
      targets = [fuse_lib] + fuse_includes
    )
    fuse_config = drake.cxx.Config()
    fuse_config.add_local_include_path('fuse/include')
    local_cxx_config += fuse_config
    fuse_lib = drake.copy(fuse_lib, 'lib', strip_prefix = True)
  elif cxx_toolkit.os is drake.os.macos:
    fuse_config = drake.cxx.Config()
    fuse_config.add_local_include_path('/usr/local/include/osxfuse')
    local_cxx_config += fuse_config
    fuse_lib = drake.cxx.DynLib('/usr/local/lib/libosxfuse.2.dylib')

  # Curl
  local_cxx_config += curl_config
  curl_lib = drake.copy(curl_lib, 'lib', strip_prefix = True)

  # OpenSSL (for SSL sockets)
  local_cxx_config += openssl_config
  openssl_libs = drake.copy([openssl_lib_ssl, openssl_lib_crypto],
                            'lib', strip_prefix = True)


  # Zlib
  local_cxx_config += zlib_config
  zlib_lib = drake.copy(zlib_lib, 'lib', strip_prefix = True)

  # Elle
  elle = elle or drake.include('../elle')
  local_cxx_config += elle.config
  elle_lib = drake.copy(elle.library, 'lib', strip_prefix = True)

  # miniupnpc
  miniupnp = drake.include('miniupnp', cxx_toolkit, archs = archs)
  miniupnpc = miniupnp.miniupnpc
  local_cxx_config += miniupnpc.config

  # Build
  rule_build = drake.Rule('build')

  # UDT
  #asio_udt = drake.include('asio-udt', cxx_toolkit, cxx_config, boost = boost)
  #asio_udt_lib = drake.copy(asio_udt.library, '', 'asio-udt')
  #udt_lib = drake.copy(asio_udt.udt.library, '', 'asio-udt/udt')

  # Asio-FS
  # asio_fs = drake.include('asio-fs', cxx_toolkit, cxx_config, boost = boost)
  # asio_fs_lib = drake.copy(asio_fs.library_dynamic, '', 'asio-fs')
  # config += asio_fs.config

  sources = drake.nodes(
    'src/reactor/Barrier.cc',
    'src/reactor/Barrier.hh',
    'src/reactor/MultiLockBarrier.cc',
    'src/reactor/MultiLockBarrier.hh',
    'src/reactor/Channel.hh',
    'src/reactor/Scope.cc',
    'src/reactor/Scope.hh',
    'src/reactor/TimeoutGuard.cc',
    'src/reactor/TimeoutGuard.hh',
    'src/reactor/asio.hh',
    # 'src/reactor/backend/pthread/pthread.cc',
    # 'src/reactor/backend/pthread/pthread.hh',
    'src/reactor/duration.cc',
    'src/reactor/duration.hh',
    'src/reactor/exception.cc',
    'src/reactor/exception.hh',
    # 'src/reactor/fs/File.hh',
    # 'src/reactor/fs/File.cc',
    'src/reactor/fsm/fwd.hh',
    'src/reactor/fsm/CatchTransition.cc',
    'src/reactor/fsm/CatchTransition.hh',
    'src/reactor/fsm/EndTransition.cc',
    'src/reactor/fsm/EndTransition.hh',
    'src/reactor/fsm/Machine.cc',
    'src/reactor/fsm/Machine.hh',
    'src/reactor/fsm/Machine.hxx',
    'src/reactor/fsm/State.cc',
    'src/reactor/fsm/State.hh',
    'src/reactor/fsm/Transition.cc',
    'src/reactor/fsm/Transition.hh',
    'src/reactor/fsm/WaitableTransition.cc',
    'src/reactor/fsm/WaitableTransition.hh',
    'src/reactor/fwd.hh',
    'src/reactor/lockable.cc',
    'src/reactor/lockable.hh',
    'src/reactor/logger.cc',
    'src/reactor/logger.hh',
    'src/reactor/mutex.cc',
    'src/reactor/mutex.hh',
    'src/reactor/network/SocketOperation.cc',
    'src/reactor/network/SocketOperation.hh',
    'src/reactor/network/buffer.hh',
    'src/reactor/network/exception.cc',
    'src/reactor/network/exception.hh',
    'src/reactor/network/fwd.hh',
    # 'src/reactor/network/nat.cc',
    # 'src/reactor/network/nat.hh',
    'src/reactor/network/Protocol.cc',
    'src/reactor/network/Protocol.hh',
    'src/reactor/network/proxy.cc',
    'src/reactor/network/proxy.hh',
    'src/reactor/network/resolve.cc',
    'src/reactor/network/resolve.hh',
    'src/reactor/network/server.cc',
    'src/reactor/network/server.hh',
    'src/reactor/network/socket.cc',
    'src/reactor/network/socket.hh',
    'src/reactor/network/tcp-server.cc',
    'src/reactor/network/tcp-server.hh',
    'src/reactor/network/tcp-socket.cc',
    'src/reactor/network/tcp-socket.hh',
    'src/reactor/network/fingerprinted-socket.cc',
    'src/reactor/network/fingerprinted-socket.hh',
    'src/reactor/network/ssl-socket.hh',
    'src/reactor/network/ssl-socket.cc',
    'src/reactor/network/ssl-socket.hh',
    'src/reactor/network/ssl-server.cc',
    'src/reactor/network/ssl-server.hh',
    'src/reactor/network/upnp.cc',
    'src/reactor/network/upnp.hh',
    # 'src/reactor/network/udt-rdv-server.cc',
    # 'src/reactor/network/udt-rdv-server.hh',
    # 'src/reactor/network/udt-server.cc',
    # 'src/reactor/network/udt-server.hh',
    # 'src/reactor/network/udt-socket.cc',
    # 'src/reactor/network/udt-socket.hh',
    'src/reactor/operation.cc',
    'src/reactor/operation.hh',
    'src/reactor/rw-mutex.cc',
    'src/reactor/rw-mutex.hh',
    'src/reactor/scheduler.cc',
    'src/reactor/scheduler.hh',
    'src/reactor/semaphore.cc',
    'src/reactor/semaphore.hh',
    'src/reactor/signal.cc',
    'src/reactor/signal.hh',
    'src/reactor/signals.hh',
    'src/reactor/sleep.cc',
    'src/reactor/sleep.hh',
    'src/reactor/storage.cc',
    'src/reactor/storage.hh',
    'src/reactor/timer.cc',
    'src/reactor/timer.hh',
    'src/reactor/thread.cc',
    'src/reactor/thread.hh',
    'src/reactor/waitable.cc',
    'src/reactor/waitable.hh',
    )
  if cxx_toolkit.os is not drake.os.windows:
    sources += drake.nodes(
      'src/reactor/fuse.hh',
      'src/reactor/fuse.cc',
      'src/reactor/filesystem.hh',
      'src/reactor/filesystem.cc',
      'src/reactor/filesystem_fuse.cc',
      'src/reactor/pthread.hh',
      'src/reactor/pthread.cc',
      )
  sources += drake.nodes(
    'src/reactor/http/Client.cc',
    'src/reactor/http/Client.hh',
    'src/reactor/http/EscapedString.cc',
    'src/reactor/http/EscapedString.hh',
    'src/reactor/http/Method.cc',
    'src/reactor/http/Method.hh',
    'src/reactor/http/Request.cc',
    'src/reactor/http/Request.hh',
    'src/reactor/http/Service.cc',
    'src/reactor/http/Service.hh',
    'src/reactor/http/StatusCode.cc',
    'src/reactor/http/StatusCode.hh',
    'src/reactor/http/Version.cc',
    'src/reactor/http/Version.hh',
    'src/reactor/http/exceptions.cc',
    'src/reactor/http/exceptions.hh',
  )

  lib_cxx_config = drake.cxx.Config(local_cxx_config)

  backend = drake.cxx.StaticLib(
    'lib/reactor/backend',
    drake.nodes(
      'src/reactor/backend/backend.cc',
      'src/reactor/backend/backend.hh',
    ),
    cxx_toolkit,
    lib_cxx_config,
  )

  backend_coro_libs = [backend]
  if cxx_toolkit.os is drake.os.windows:
    backend_coro_libs += [libcoroutine]

  backend_coro_io = drake.cxx.StaticLib(
    'lib/reactor/backend_coro_io',
    drake.nodes(
      'src/reactor/backend/coro_io/backend.cc',
      'src/reactor/backend/coro_io/backend.hh',
    ) + backend_coro_libs,
    cxx_toolkit,
    lib_cxx_config,
  )

  backend_boost_context_cxx_config = drake.cxx.Config(lib_cxx_config)
  backend_boost_context = drake.cxx.StaticLib(
    'lib/reactor/backend_boost_context',
    drake.nodes(
      'src/reactor/backend/boost_context/backend.cc',
      'src/reactor/backend/boost_context/backend.hh',
    ),
    cxx_toolkit,
    backend_boost_context_cxx_config,
  )

  lib_static_link_libs = [
    curl_lib,
    elle.lib_static,
    miniupnpc.library,
  ]
  if cxx_toolkit.os is drake.os.windows:
    lib_static_link_libs.append(libcoroutine)
    lib_static_link_libs.append(backend_coro_io)
  else:
    lib_static_link_libs.append(backend_boost_context)
    lib_static_link_libs.append(backend)
  lib_static = drake.cxx.StaticLib(
    'lib/reactor',
    sources + lib_static_link_libs + openssl_libs,
    cxx_toolkit, lib_cxx_config)
  lib_dynamic_link_libs = [
    curl_lib,
    elle_lib,
    miniupnpc.library,
  ]
  if cxx_toolkit.os is drake.os.windows:
    lib_dynamic_link_libs.append(libcoroutine)
    lib_dynamic_link_libs.append(backend_coro_io)
  else:
    lib_dynamic_link_libs.append(backend_boost_context)
    lib_dynamic_link_libs.append(backend)
  if cxx_toolkit.os is not drake.os.windows:
    lib_dynamic_link_libs.append(fuse_lib)
  lib_dynamic = drake.cxx.DynLib(
    'lib/reactor',
    sources + lib_dynamic_link_libs + openssl_libs,
    cxx_toolkit, lib_cxx_config)
  rule_build << lib_static
  if cxx_toolkit.os in [drake.os.windows, drake.os.ios]:
    library = lib_static
  else:
    rule_build << lib_dynamic
    library = lib_dynamic

  if python3 is not None:
    python_cxx_config = drake.cxx.Config(local_cxx_config)
    python_cxx_config.lib_path_runtime('..')
    python_cxx_config += python3
    if cxx_toolkit.os is drake.os.windows:
      python_cxx_config += boost.config_python(static = True)
    else:
      python_cxx_config += boost.config_python(link = False)
      python_cxx_config.library_add(
        drake.copy(boost.python_dynamic, 'lib', strip_prefix = True))
    python_sources = drake.nodes('src/reactor/python.cc')
    datetime = drake.copy(elle.python_plugin_datetime,
                          'lib', True)
    python_lib = drake.cxx.Module('lib/python/reactor',
                                  python_sources + [library, datetime],
                                  cxx_toolkit, python_cxx_config)
    drake.Rule('python') << python_lib
    rule_build << python_lib

  ## ----- ##
  ## Tests ##
  ## ----- ##

  global rule_check, rule_tests
  rule_check = drake.TestSuite('check')
  rule_tests = drake.Rule('tests')

  tests = [
    ('backend', []),
    ('fsm', []),
    ('http', [curl_lib]),
    ('logger', []),
    ('network', []),
    ('reactor', []),
    ('upnp', []), # Not an auto test, just an utility.
    ('ssl', openssl_libs),
    # 'reactor/file',
    ]
  if cxx_toolkit.os is not drake.os.windows:
    tests.append(('filesystem', []))
    tests.append(('filesystem_bind', []))
    tests.append(('filesystem_git', []))

  cxx_config_tests = drake.cxx.Config(local_cxx_config)
  cxx_config_tests.add_local_include_path('tests')
  cxx_config_tests += boost.config_filesystem(static = (cxx_toolkit.os in [drake.os.macos, drake.os.ios]) or None)
  if cxx_toolkit.os in [drake.os.windows, drake.os.ios]:
    cxx_config_tests += boost.config_test(static = True)
  else:
    cxx_config_tests += boost.config_test(link = False)
    cxx_config_tests.library_add(
      drake.copy(boost.test_dynamic, 'lib', strip_prefix = True))

  for test_name, libraries in tests:
    tests_config = drake.cxx.Config(cxx_config_tests)
    tests_config.lib_path_runtime('%s../lib' % ('../' * test_name.count('/')))
    sources = drake.nodes('tests/%s.cc' % test_name) + [
      library, elle_lib
      ] + libraries
    test = drake.cxx.Executable('tests/%s' % test_name,
                                sources,
                                cxx_toolkit, tests_config)
    rule_tests << test
    if test_name in ['filesystem_git', 'filesystem_bind',]:
      continue
    env = {
      'DIR_BUILD':  str(drake.path_build()),
      'DIR_SOURCE': str(drake.path_source()),
    }
    if cxx_toolkit.os is drake.os.windows and sys.platform is 'linux':
      env['RUNNING_ON_WINE'] = '1'
    if valgrind_tests:
      runner = drake.valgrind.ValgrindRunner(exe = test,
                                             valgrind = valgrind,
                                             env = env)
    else:
      runner = drake.Runner(exe = test, env = env)
    runner.reporting = drake.Runner.Reporting.on_failure
    rule_check << runner.status

  if python3 is not None and cxx_toolkit.os is not drake.os.windows:
    python_tests = (
      'tests/python',
      )
    with drake.templating.Context(content = {
        'python_interpreter': str(python3.python_interpreter),
    }):
      for test in python_tests:
        drake.node('%s.tmpl' % python_tests)
    for test in python_tests:
      test = drake.node(test)
      test.dependency_add(python_lib)
      python_runner = drake.Runner(
        exe = test,
        env = {
          'PYTHONPATH': str(drake.path_build('lib/python')),
        },
        )
      rule_check << python_runner.status

  # Install
  rule_install = drake.Rule('install')
  if cxx_toolkit.os not in [drake.os.windows, drake.os.ios]:
    rule_install << drake.install(lib_dynamic, prefix)
  rule_install << drake.install(lib_static, prefix)
  rule_install << drake.install(
    list(filter(lambda n: isinstance(n, drake.cxx.Header), sources)),
    prefix / 'include', 'src')
