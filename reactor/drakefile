import drake
import drake.cxx
import drake.cxx.boost

config = None
lib_static = None
lib_dynamic = None

rule_build = None
rule_check = None
rule_install = None

def configure(cxx_toolkit = None,
              cxx_config = None,
              boost = None,
              elle = None,
              prefix = '/usr'):

  global config, lib_static, lib_dynamic
  global rule_build, rule_check, rule_install

  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()
  cxx_config = cxx_config or drake.cxx.Config()

  config = drake.cxx.Config()
  config.add_local_include_path('src')
  config.standard = drake.cxx.Config.cxx_0x
  config.lib_path('lib')
  cxx_config += config

  elle = elle or drake.include('../elle')
  cxx_config += elle.config

  # UDT
  asio_udt = drake.include('asio-udt', cxx_toolkit, cxx_config, boost = boost)
  asio_udt_lib = drake.copy(asio_udt.library, '', 'asio-udt')
  udt_lib = drake.copy(asio_udt.udt.library, '', 'asio-udt/udt')
  cxx_config = drake.cxx.Config(cxx_config)
  cxx_config += asio_udt.config
  cxx_config.enable_debug_symbols()

  sources = drake.nodes(
    'src/reactor/asio.hh',
    'src/reactor/backend/coro_io/libcoroutine/asm.S',
    'src/reactor/backend/coro_io/libcoroutine/context.cc',
    'src/reactor/backend/coro_io/libcoroutine/coroutine.cc',
    'src/reactor/backend/coro_io/libcoroutine/coroutine.hh',
    'src/reactor/backend/coro_io/thread.cc',
    'src/reactor/backend/coro_io/thread.hh',
    'src/reactor/backend/pthread/pthread.cc',
    'src/reactor/backend/pthread/pthread.hh',
    'src/reactor/backend/thread.hh',
    'src/reactor/duration.cc',
    'src/reactor/duration.hh',
    'src/reactor/exception.cc',
    'src/reactor/exception.hh',
    'src/reactor/fwd.hh',
    'src/reactor/lockable.cc',
    'src/reactor/lockable.hh',
    'src/reactor/logger.cc',
    'src/reactor/mutex.cc',
    'src/reactor/mutex.hh',
    'src/reactor/network/Protocol.hh',
    'src/reactor/network/buffer.hh',
    'src/reactor/network/exception.cc',
    'src/reactor/network/exception.hh',
    'src/reactor/network/fwd.hh',
    'src/reactor/network/resolve.cc',
    'src/reactor/network/resolve.hh',
    'src/reactor/network/server.cc',
    'src/reactor/network/server.hh',
    'src/reactor/network/socket-operation.hh',
    'src/reactor/network/socket.cc',
    'src/reactor/network/socket.hh',
    'src/reactor/network/tcp-server.cc',
    'src/reactor/network/tcp-server.hh',
    'src/reactor/network/tcp-socket.cc',
    'src/reactor/network/tcp-socket.hh',
    'src/reactor/network/udp-socket.cc',
    'src/reactor/network/udp-socket.hh',
    'src/reactor/network/udt-server.cc',
    'src/reactor/network/udt-server.hh',
    'src/reactor/network/udt-socket.cc',
    'src/reactor/network/udt-socket.hh',
    'src/reactor/operation.cc',
    'src/reactor/operation.hh',
    'src/reactor/rw-mutex.cc',
    'src/reactor/rw-mutex.hh',
    'src/reactor/scheduler.cc',
    'src/reactor/scheduler.hh',
    'src/reactor/semaphore.cc',
    'src/reactor/semaphore.hh',
    'src/reactor/signal.cc',
    'src/reactor/signal.hh',
    'src/reactor/sleep.cc',
    'src/reactor/sleep.hh',
    'src/reactor/storage.cc',
    'src/reactor/storage.hh',
    'src/reactor/thread.cc',
    'src/reactor/thread.hh',
    'src/reactor/waitable.cc',
    'src/reactor/waitable.hh',
    )

  lib_static = drake.cxx.StaticLib('lib/reactor', sources + [asio_udt_lib], cxx_toolkit, cxx_config)
  lib_dynamic = drake.cxx.DynLib('lib/reactor', sources + [asio_udt_lib], cxx_toolkit, cxx_config)

  # Build
  rule_build = drake.Rule('build')
  rule_build << lib_static
  rule_build << lib_dynamic

  # Tests
  rule_check = drake.Rule('check')

  tests = [
    'reactor/backend',
    'reactor/logger',
    'reactor/network',
    'reactor/reactor',
    ]

  class TestRunner(drake.Builder):

    def __init__(self, test):
      self.__test = test
      self.__out = drake.node('%s.out' % test.name())
      self.__err = drake.node('%s.err' % test.name())
      self.__status = drake.node('%s.status' % test.name())
      drake.Builder.__init__(self, [test], [self.__out, self.__err, self.__status])

    @property
    def status(self):
      return self.__status

    def execute(self):
      import subprocess
      path = str(self.__test.path())
      with open(str(self.__out.path()), 'w') as out, \
           open(str(self.__err.path()), 'w') as err, \
           open(str(self.__status.path()), 'w') as rv:
        self.output(path, 'Test %s' % self.__test)
        p = subprocess.Popen(path, stdout = out, stderr = err)
        p.wait()
        status = p.returncode
        print(status, file = rv)
      return status == 0

  boost = boost or drake.cxx.boost.Boost()

  cxx_config_tests = cxx_config + config
  cxx_config_tests += boost.config()
  cxx_config_tests += boost.config_filesystem()
  cxx_config_tests += boost.config_system()
  cxx_config_tests += boost.config_test()

  for test in tests:
    config = drake.cxx.Config(cxx_config_tests)
    config.lib_path_runtime('%s../../lib' % ('../' * test.count('/')))
    config.lib('elle')
    test = drake.cxx.Executable('tests/%s' % test,
                                drake.nodes('tests/%s.cc' % test) + [lib_dynamic],
                                cxx_toolkit, config)
    runner = TestRunner(test)
    rule_check << runner.status

  # Install
  rule_install = drake.Rule('install')
  rule_install << drake.copy(lib_dynamic, prefix)
  rule_install << drake.copy(lib_static, prefix)
  rule_install << drake.copy(list(filter(lambda n: isinstance(n, drake.cxx.Header), sources)), prefix / 'include', 'src')
