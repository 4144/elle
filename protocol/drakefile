import drake
import drake.cxx
import drake.cxx.boost

config = None
lib_static = None
lib_dynamic = None

rule_build = None
rule_check = None
rule_install = None
rule_tests = None

def configure(cryptography,
              elle,
              reactor,
              cxx_toolkit = None,
              cxx_config = None,
              boost = None,
              stuntman = None,
              prefix = '/usr',
              valgrind = None):

  # Public C++ configuration
  global config
  config = drake.cxx.Config()
  config.add_local_include_path('src')
  config.standard = drake.cxx.Config.cxx_11

  # Boost
  boost = boost or drake.cxx.boost.Boost()
  config += boost.config()

  # Elle
  config += elle.config
  elle_lib = drake.copy(elle.lib_dynamic, 'lib',
                        elle.lib_dynamic.name().dirname())

  # Reactor
  config += reactor.config
  reactor_lib = drake.copy(reactor.lib_dynamic, 'lib',
                           reactor.lib_dynamic.name().dirname())

  # Cryptography
  config += cryptography.config
  cryptography_lib = drake.copy(cryptography.lib_dynamic, 'lib',
                                cryptography.lib_dynamic.name().dirname())

  # Local C++ configuration
  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()
  local_cxx_config = drake.cxx.Config(cxx_config)
  local_cxx_config.lib_path_runtime('.')
  local_cxx_config.enable_debug_symbols()
  local_cxx_config += config

  # # Boost libraries
  # local_cxx_config += boost.config_signals()
  # local_cxx_config += boost.config_system()
  # local_cxx_config += boost.config_thread()

  sources = drake.nodes(
    'src/protocol/ChanneledStream.hh',
    'src/protocol/Packet.hh',
    'src/protocol/RPC.hxx',
    'src/protocol/Packet.cc',
    'src/protocol/Stream.hh',
    'src/protocol/Serializer.hh',
    'src/protocol/Channel.cc',
    'src/protocol/RPC.hh',
    'src/protocol/ChanneledStream.cc',
    'src/protocol/Stream.cc',
    'src/protocol/Channel.hh',
    'src/protocol/Serializer.cc',
    'src/protocol/RPC.cc',
    'src/protocol/exceptions.cc',
    'src/protocol/exceptions.hh',
    'src/protocol/fwd.hh',
  )
  global lib_static, lib_dynamic
  from itertools import chain
  lib_static = drake.cxx.StaticLib(
    'lib/protocol',
    chain(sources, (elle_lib, reactor_lib, cryptography_lib)),
    cxx_toolkit, local_cxx_config)
  lib_dynamic = drake.cxx.DynLib(
    'lib/protocol',
    chain(sources, (elle_lib, reactor_lib, cryptography_lib)),
    cxx_toolkit, local_cxx_config)

  # Build
  global rule_build
  rule_build = drake.Rule('build')
  rule_build << lib_static
  rule_build << lib_dynamic

  # Tests
  global rule_check, rule_tests
  rule_check = drake.TestSuite('check')
  rule_tests = drake.Rule('tests')

  tests = [
    'rpc',
    'serializer',
    ]

  cxx_config_tests = drake.cxx.Config(local_cxx_config)
  cxx_config_tests += boost.config_test()
  cxx_config_tests.lib_path_runtime('../lib')

  for name in tests:
    test = drake.cxx.Executable(
      'tests/%s' % name,
      (drake.node('tests/%s.cc' % name),
       lib_dynamic, elle_lib, reactor_lib),
      cxx_toolkit, cxx_config_tests)
    rule_tests << test
    if valgrind is not None:
      runner = drake.valgrind.ValgrindRunner(exe = test,
                                             valgrind = valgrind)
    else:
      runner = drake.Runner(exe = test)
    runner.reporting = drake.Runner.Reporting.on_failure
    rule_check << runner.status

  # Install
  global rule_install
  rule_install = drake.Rule('install')
  rule_install << drake.install(lib_dynamic, prefix)
  rule_install << drake.install(lib_static, prefix)
  rule_install << drake.install(
    (node for node in sources if isinstance(node, drake.cxx.Header)),
    prefix / 'include', 'src')
