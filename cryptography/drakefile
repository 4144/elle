import os

import drake
import drake.cxx
import drake.cxx.boost
import drake.valgrind

config = None
lib_static = None
lib_dynamic = None
library = None

rule_build = None
rule_check = None
rule_install = None
rule_tests = None

def configure(openssl_config,
              openssl_lib_crypto,
              openssl_lib_ssl,
              cxx_toolkit = None,
              cxx_config = drake.cxx.Config(),
              enable_rotation = False,
              dopenssl = None,
              boost = None,
              elle = None,
              prefix = '/usr',
              valgrind = None):

  global config
  global lib_static, lib_dynamic, library
  global rule_build, rule_install

  # Toolkit
  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()
  cxx_config = drake.cxx.Config(cxx_config)

  # Libraries
  openssl_libs = drake.copy([openssl_lib_crypto, openssl_lib_ssl],
                            'lib', strip_prefix = True)
  if enable_rotation:
    cxx_config.define("ELLE_CRYPTOGRAPHY_ROTATION")
    dopenssl = drake.cxx.find_library('dopenssl/all.h', dopenssl)
  boost = boost or drake.cxx.boost.Boost()
  if cxx_toolkit.os in [drake.os.windows, drake.os.ios]:
    boost_test = boost.config_test(static = True)
    boost_thread = boost.config_thread(static = True)
  else:
    boost_test = drake.cxx.Config(boost.config_test(link = False))
    boost_test.library_add(drake.copy(boost.test_dynamic, 'lib', strip_prefix = True))
    boost_thread = drake.cxx.Config(boost.config_thread(link = False))
    boost_thread.library_add(drake.copy(boost.thread_dynamic, 'lib', strip_prefix = True))

  elle_lib_static = elle.lib_static
  elle_lib_dynamic = drake.copy(elle.lib_dynamic, 'lib', strip_prefix = True)

  # Global Configuration
  config = drake.cxx.Config()
  config.standard = drake.cxx.Config.cxx_11
  config.add_local_include_path('sources')
  config.lib_path('lib')
  if enable_rotation:
    config += dopenssl
  # XXX: openssl should not be leaked.
  # cryptography/fwd.hh leaks EVP_PKEY_CTX for instance.
  config += openssl_config

  # Local Configuration
  cxx_config = drake.cxx.Config(cxx_config)
  cxx_config += config
  cxx_config += boost.config()
  if cxx_toolkit.os in [drake.os.ios, drake.os.windows]:
    cxx_config += boost.config_system(static = True)
  else:
    cxx_config += boost.config_system(link = False)
    cxx_config.library_add(
      drake.copy(boost.system_dynamic, 'lib', strip_prefix = True))

  cxx_config += elle.config
  cxx_config += openssl_config

  # Sources
  sources = drake.nodes(
    'sources/cryptography/Clear.hh',
    'sources/cryptography/Code.hh',
    'sources/cryptography/Cryptosystem.cc',
    'sources/cryptography/Cryptosystem.hh',
    'sources/cryptography/deleter.cc',
    'sources/cryptography/deleter.hh',
    'sources/cryptography/Digest.hh',
    'sources/cryptography/Exception.hh',
    'sources/cryptography/Exception.cc',
    'sources/cryptography/Input.cc',
    'sources/cryptography/Input.hh',
    'sources/cryptography/KeyPair.cc',
    'sources/cryptography/KeyPair.hh',
    'sources/cryptography/KeyPair.hxx',
    'sources/cryptography/Output.cc',
    'sources/cryptography/Output.hh',
    'sources/cryptography/Output.hxx',
    'sources/cryptography/Plain.hh',
    'sources/cryptography/PrivateKey.cc',
    'sources/cryptography/PrivateKey.hh',
    'sources/cryptography/PrivateKey.hxx',
    'sources/cryptography/PublicKey.cc',
    'sources/cryptography/PublicKey.hh',
    'sources/cryptography/PublicKey.hxx',
    'sources/cryptography/SecretKey.cc',
    'sources/cryptography/SecretKey.hh',
    'sources/cryptography/SecretKey.hxx',
    'sources/cryptography/Signature.hh',
    'sources/cryptography/all.hh',
    'sources/cryptography/bn.cc',
    'sources/cryptography/bn.hh',
    'sources/cryptography/bn.hxx',
    'sources/cryptography/challenge.cc',
    'sources/cryptography/challenge.hh',
    'sources/cryptography/cipher.cc',
    'sources/cryptography/cipher.hh',
    'sources/cryptography/cryptography.cc',
    'sources/cryptography/cryptography.hh',
    'sources/cryptography/evp.cc',
    'sources/cryptography/evp.hh',
    'sources/cryptography/finally.hh',
    'sources/cryptography/fwd.hh',
    'sources/cryptography/oneway.cc',
    'sources/cryptography/oneway.hh',
    'sources/cryptography/oneway.hxx',
    'sources/cryptography/pem.cc',
    'sources/cryptography/pem.hh',
    'sources/cryptography/pem.hxx',
    'sources/cryptography/random.cc',
    'sources/cryptography/random.hh',
    'sources/cryptography/random.hxx',
    'sources/cryptography/rsa/PrivateKey.cc',
    'sources/cryptography/rsa/PrivateKey.hh',
    'sources/cryptography/rsa/PrivateKey.hxx',
    'sources/cryptography/rsa/PublicKey.cc',
    'sources/cryptography/rsa/PublicKey.hh',
    'sources/cryptography/rsa/PublicKey.hxx',
    'sources/cryptography/rsa/all.hh',
    'sources/cryptography/rsa/fwd.hh',
    'sources/cryptography/rsa/keypair.cc',
    'sources/cryptography/rsa/keypair.hh',
    'sources/cryptography/rsa/padding.cc',
    'sources/cryptography/rsa/padding.hh',
    'sources/cryptography/types.hh',
    )

  if enable_rotation:
    sources += drake.nodes(
      'sources/cryptography/Seed.cc',
      'sources/cryptography/Seed.hh',
      'sources/cryptography/Seed.hxx',
      'sources/cryptography/rsa/Seed.cc',
      'sources/cryptography/rsa/Seed.hh',
      'sources/cryptography/rsa/Seed.hxx',
      )

  cxx_config_lib = drake.cxx.Config(cxx_config)
  if enable_rotation:
    cxx_config.lib('dopenssl')
  cxx_config_lib.lib_path_runtime('.')

  lib_static = drake.cxx.StaticLib('lib/cryptography',
                                   sources + [elle_lib_static] + openssl_libs,
                                   cxx_toolkit,
                                   cxx_config_lib)
  lib_dynamic = drake.cxx.DynLib('lib/cryptography',
                                 sources + [elle_lib_dynamic] + openssl_libs,
                                 cxx_toolkit,
                                 cxx_config_lib)

  # Build
  rule_build = drake.Rule('build')
  rule_build << lib_static
  if cxx_toolkit.os not in [drake.os.windows, drake.os.ios]:
    rule_build << lib_dynamic
    library = lib_dynamic
  else:
    library = lib_static

  # Tests
  tests = [
    "Input.cc",
    "KeyPair.cc",
    "Output.cc",
    "PrivateKey.cc",
    "PublicKey.cc",
    "SecretKey.cc",
    "bn.cc",
    "challenge.cc",
    "oneway.cc",
    "random.cc",
     ]
  if enable_rotation:
    tests += [ "Seed.cc" ]

  tests_cxx_config = drake.cxx.Config(cxx_config)
  tests_cxx_config += config
  tests_cxx_config += boost.config()
  tests_cxx_config += boost_test
  tests_cxx_config += boost_thread
  tests_cxx_config += openssl_config
  if enable_rotation:
    tests_cxx_config += dopenssl
  tests_cxx_config += elle.config

  global rule_check, rule_tests
  rule_check = drake.TestSuite('check')
  rule_tests = drake.Rule('tests')
  for test in tests:
    config_test = drake.cxx.Config(tests_cxx_config)
    config_test.lib_path_runtime('%s../../lib' % ('../' * test.count('/')))
    path = drake.Path('tests/cryptography/%s' % test)
    bin_path = drake.Path('tests/cryptography/%s' % os.path.splitext(test)[0])
    sources = drake.nodes(path)
    sources.append(library)
    sources.append(elle.lib_dynamic)
    sources.append(openssl_lib_crypto) # Some tests use BIGNUM
    bin = drake.cxx.Executable(bin_path, sources,
                               cxx_toolkit, config_test)
    rule_tests << bin
    if valgrind is not None:
      runner = drake.valgrind.ValgrindRunner(exe = bin,
                                             valgrind = valgrind)
    else:
      runner = drake.Runner(exe = bin)
    runner.reporting = drake.Runner.Reporting.on_failure
    rule_check << runner.status

  # Install
  rule_install = drake.Rule('install')
  prefix = drake.Path(prefix)
  if cxx_toolkit.os not in [drake.os.windows, drake.os.ios]:
    rule_install << drake.install(lib_dynamic, prefix)
  rule_install << drake.install(lib_static, prefix)
  rule_install << drake.install(
    list(filter(lambda n: isinstance(n, drake.cxx.Header), sources)),
    prefix / 'include', 'sources')
