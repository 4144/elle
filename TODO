- tenter de lancer replay sans avoir reinit le reseau -> ca segfault
- trouver un synonyme de Resolve pour Wall:: Test, Analyse, Reduce, Settle
  => Path::Resolve devrait retourner true/false ou error

#
# ---------- long-term --------------------------------------------------------
#

- pour le locking il faudrait deja faire en sorte que plusieurs scope
  reference un context. comme ca on lockera le contexte a partir d'un
  scope, rendant les autres scopes unusable.

- dans wall faire Transaction puis Apply. difference entre des ref
  en live et normal lorsqu'on l'extract
- peut etre attacher des objects a une fibre: report, session ou autre.
  comment ca pas besoin de govern.

- error si on destroy avec des modifs: comme ca si deux ouvertures et
  un fait des modifs et ensuite se retract ben on peut faire une erreur.

- wrapper de methodes: il faut lorsque l'on decrit une procedure indique
  si 1) il y a des valeurs en retour auquel cas il faut les envoyer au
  client 2) si il faut transmettre le resultat Ok/Error

- pourquoi il reste autant de blocks
  => un repertoire est mis a jour N fois puis est Destroy
  => Destroy vire les Objects pour les N versions et les derniers blocks
     de data. il reste donc N blocs de data!

- timeout dans les sockets: en sychone le WaitForReadyRead a un timeout
  par default de 30s alors qu'en asynchrone on fait Fiber::Wait qui
  est infini => le Fiber::Wait devrait prendre un timeout.
