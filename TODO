- faire prolog pour Server/Client: authenticated?
- faire un type Result/Return template avec la donnee que l'on attend
  vraiment -> si error, rien n'est retourne => necessaire car si une
  procedure doit retourner un Block, elle pourrait aussi retourner une erreur!
- dans Registrar: faire que le Register prenne une classe container
  avec premier param Status et ensuite des Parameters
- classe Return
- return type pour Function/Method et Closure
- return-specific pour Void: function, method, callback, closure
- systeme de reservation de tag un a un : static counter
- appliquer le concept de Procedure aux tests
- union pour Variables aussi
- trigger pour Arguments/Variables
- le constructeur de Arguments ne devrait pas etre aussi precis: juste X<Q>
  et ensuite l'assignment fera le reste -> permettra de gerer non-const->const
  meme chose pour Variables
- simplifier les doublons dans Arguments/Variables en ne gardant que les
  methodes const (pire cas)

- error: could not convert template argument ‘(hole::implementations::remote::Tag)7u’ to ‘elle::Tag’
- faire que Network::Register register aupres de Registrar le callback
  qui est dans la procedure associee avec le tag! sauf si le method appellee
  est Register(Procedure) -> mieux: ca prend tjs une procedure
- wrapper de methodes: il faut lorsque l'on decrit une procedure indiquer
  si 1) il y a des valeurs en retour auquel cas il faut les envoyer au
  client 2) si il faut transmettre le resultat Ok/Error 3) prolog/epilog

- tenter de lancer replay sans avoir reinit le reseau -> ca segfault
- trouver un synonyme de Resolve pour Wall:: Test, Analyse, Reduce, Settle
  => Path::Resolve devrait retourner true/false ou error

#
# ---------- long-term --------------------------------------------------------
#

- pour le locking il faudrait deja faire en sorte que plusieurs scope
  reference un context. comme ca on lockera le contexte a partir d'un
  scope, rendant les autres scopes unusable.

- dans wall faire Transaction puis Apply. difference entre des ref
  en live et normal lorsqu'on l'extract
- peut etre attacher des objects a une fibre: report, session ou autre.
  comment ca pas besoin de govern.

- error si on destroy avec des modifs: comme ca si deux ouvertures et
  un fait des modifs et ensuite se retract ben on peut faire une erreur.

- pourquoi il reste autant de blocks
  => un repertoire est mis a jour N fois puis est Destroy
  => Destroy vire les Objects pour les N versions et les derniers blocks
     de data. il reste donc N blocs de data!

- timeout dans les sockets: en sychone le WaitForReadyRead a un timeout
  par default de 30s alors qu'en asynchrone on fait Fiber::Wait qui
  est infini => le Fiber::Wait devrait prendre un timeout.
