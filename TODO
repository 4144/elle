- ajouter un truc adns le constr Signal: Post ou Send
 -> pour ca il faut pouvoir delay les events: avec SendEvents/PostEvents
  => simplement via un Timer(0) que l'on cree si signal Send et qu'on
     start quand on emit: Call()

- utiliser infer a la place des callbacks.
- mettre des signaux sur les sockets

- bouger Morgue dans standalone.

- pour eviter les bury ou delete this dans Neighbour.cc
  il faut utiliser un system de signals

- cluster: virer label: sert a rien
- ajouter timeout pour rester dans neighbour sans etre authenticated?
- neighbour -> vestibule -> authenticated -> routing table

- il semble que lorsqu'on copie des fichiers dans Infinit, ils
  choppent le bit x
- timeout sur Cirkle::Neighbour?

- trouver un terme pour remplacer Address dans elle:
  Plug/Spot/Site/Place/Station

- renommer Node en Host dans remote.
- mettre RoutingTable en fonctionnalite generale

- routingtable en global template par T (type d'entree): contient une map
  indexee par label. class Mass cree a partir de la RTable?

#
# ---------- XXX --------------------------------------------------------------
#

- shrub: faire des listes pour les meme timestamps dans queue
- make: Warning: File `Makefile' has modification time 3557 s in the future

- refaire marcher diary::record -> record make de linux (sans la copie)
- virer diary/ de pig et mettre dans 8diary. si lance avec option
  infinit, on link avec infinit et on bande.

- note that the data modifications should probably update the object's data as well such as the size, timestamps etc. so that, say, a file being opened, modified and reopened in order to get the current size returns the new size instead of the "current" one. => quand on fait un Information, si data have been modified, make it consistent
- passer les versions en 64-bit car un script qui update un fichier toutes les secondes -> vite fait le tour!

#
# ---------- long-term --------------------------------------------------------
#

- pour le locking il faudrait deja faire en sorte que plusieurs scope
  reference un context. comme ca on lockera le contexte a partir d'un
  scope, rendant les autres scopes unusable.

- dans wall faire Transaction puis Apply. difference entre des ref
  en live et normal lorsqu'on l'extract
- peut etre attacher des objects a une fibre: report, session ou autre.
  comment ca pas besoin de govern.

- error si on destroy avec des modifs: comme ca si deux ouvertures et
  un fait des modifs et ensuite se retract ben on peut faire une erreur.

- pourquoi il reste autant de blocks
  => un repertoire est mis a jour N fois puis est Destroy
  => Destroy vire les Objects pour les N versions et les derniers blocks
     de data. il reste donc N blocs de data!

- timeout dans les sockets: en sychone le WaitForReadyRead a un timeout
  par default de 30s alors qu'en asynchrone on fait Fiber::Wait qui
  est infini => le Fiber::Wait devrait prendre un timeout.

- ameliorer le replay: quand on avance jusqu'au from, activer un flag. si
  le flag est active, ne pas appeler FUSE mais quand meme gerer Live.

- copier video -> ca chie et Infinit passe a 480 Mo de RAM!
  => ca doit marcher et avec peu de RAM => plante car block Data trop gros
  => il faudrait decouper!

- utiliser une bsddb ou autre bref une DB local plutot que de stocker les blocs
  dans le FS car pas optimise pour ca => ca devrait ameliorer les perfs.

- rajouter des timeouts sur les I/Os, sur les sockets etc.
