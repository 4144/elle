- virer les report(), etc. et utiliser log!
- virer diary/ de pig et mettre dans 8diary. si lance avec option
  infinit, on link avec infinit et on bande.
- copier video -> ca chie et Infinit passe a 480 Mo de RAM!
  => ca doit marcher et avec peu de RAM => plante car block Data trop gros
  => il faudrait decouper!

Scope::Load -> scope
new Actor -> actor
actor->Create(); // -> new ID
scope->Attach(actor);
[...]
scope->Detach(actor);
scope->Store()


operation quelconque: ID
XXX


il faut pouvoir:
- recuperer un actor a partir de son ID => container d'actors (Gear)
- recuperer un scope a partir de son chemin => container de scopes (Gear)

#
# ---------- long-term --------------------------------------------------------
#

- pour le locking il faudrait deja faire en sorte que plusieurs scope
  reference un context. comme ca on lockera le contexte a partir d'un
  scope, rendant les autres scopes unusable.

- dans wall faire Transaction puis Apply. difference entre des ref
  en live et normal lorsqu'on l'extract
- peut etre attacher des objects a une fibre: report, session ou autre.
  comment ca pas besoin de govern.

- error si on destroy avec des modifs: comme ca si deux ouvertures et
  un fait des modifs et ensuite se retract ben on peut faire une erreur.

- pourquoi il reste autant de blocks
  => un repertoire est mis a jour N fois puis est Destroy
  => Destroy vire les Objects pour les N versions et les derniers blocks
     de data. il reste donc N blocs de data!

- timeout dans les sockets: en sychone le WaitForReadyRead a un timeout
  par default de 30s alors qu'en asynchrone on fait Fiber::Wait qui
  est infini => le Fiber::Wait devrait prendre un timeout.

- ameliorer le replay: quand on avance jusqu'au from, activer un flag. si
  le flag est active, ne pas appeler FUSE mais quand meme gerer Live.
