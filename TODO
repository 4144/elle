- chercher tous les callbacks: remplacer par des signaux: timer etc.

	// dans Meta, on a un Domain: ensemble de signaux, donc lie a un objet
	// lorsque l'on veut emit le signal, on fait this->Emit(SignalXXX, ..);
	// chaque signal est identifie par un Natural32
	// pour register un signal on fait this->Schedule< Param<> >
	// enfin pour subscribe a un signal: object.Subscribe(SignalXXX, cb);
	// lorsqu'Emit() est appelle, tous les callbacks sont triggered.
	// Unsubscribe egalement
	// faire fonctionner avec Closure egalement

- pour eviter les bury ou delete this dans Neighbour.cc
  il faut utiliser un system de signals

- cluster: virer label: sert a rien
- ajouter timeout pour rester dans neighbour sans etre authenticated?
- neighbour -> vestibule -> authenticated -> routing table

- il semble que lorsqu'on copie des fichiers dans Infinit, ils
  choppent le bit x
- timeout sur Cirkle::Neighbour?

- systeme de signal
  [QT] connect(this->gate, _connected, this, _connected)
  [Elle] dans gate, Register("suce", Parameters<...>);
  [Elle] this->gate.Attach("suce", Callback(...));
  [Elle] this->gate.Signal("suce", parameters);

- trouver un terme pour remplacer Address dans elle:
  Plug/Spot/Site/Place/Station

- renommer Node en Host dans remote.
- mettre RoutingTable en fonctionnalite generale

- routingtable en global template par T (type d'entree): contient une map
  indexee par label. class Mass cree a partir de la RTable?

#
# ---------- XXX --------------------------------------------------------------
#

- shrub: faire des listes pour les meme timestamps dans queue
- make: Warning: File `Makefile' has modification time 3557 s in the future

- refaire marcher diary::record -> record make de linux (sans la copie)
- virer diary/ de pig et mettre dans 8diary. si lance avec option
  infinit, on link avec infinit et on bande.

- note that the data modifications should probably update the object's data as well such as the size, timestamps etc. so that, say, a file being opened, modified and reopened in order to get the current size returns the new size instead of the "current" one. => quand on fait un Information, si data have been modified, make it consistent
- passer les versions en 64-bit car un script qui update un fichier toutes les secondes -> vite fait le tour!

#
# ---------- long-term --------------------------------------------------------
#

- pour le locking il faudrait deja faire en sorte que plusieurs scope
  reference un context. comme ca on lockera le contexte a partir d'un
  scope, rendant les autres scopes unusable.

- dans wall faire Transaction puis Apply. difference entre des ref
  en live et normal lorsqu'on l'extract
- peut etre attacher des objects a une fibre: report, session ou autre.
  comment ca pas besoin de govern.

- error si on destroy avec des modifs: comme ca si deux ouvertures et
  un fait des modifs et ensuite se retract ben on peut faire une erreur.

- pourquoi il reste autant de blocks
  => un repertoire est mis a jour N fois puis est Destroy
  => Destroy vire les Objects pour les N versions et les derniers blocks
     de data. il reste donc N blocs de data!

- timeout dans les sockets: en sychone le WaitForReadyRead a un timeout
  par default de 30s alors qu'en asynchrone on fait Fiber::Wait qui
  est infini => le Fiber::Wait devrait prendre un timeout.

- ameliorer le replay: quand on avance jusqu'au from, activer un flag. si
  le flag est active, ne pas appeler FUSE mais quand meme gerer Live.

- copier video -> ca chie et Infinit passe a 480 Mo de RAM!
  => ca doit marcher et avec peu de RAM => plante car block Data trop gros
  => il faudrait decouper!

- utiliser une bsddb ou autre bref une DB local plutot que de stocker les blocs
  dans le FS car pas optimise pour ca => ca devrait ameliorer les perfs.

- rajouter des timeouts sur les I/Os, sur les sockets etc.
