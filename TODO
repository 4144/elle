protocole:
  - A se connecte a B
  - B envoie son passport (sa partie publique)
  - A verifie le passport/node
  - A ajoute une entree a sa routing table

#
# ---------- XXX --------------------------------------------------------------
#

- systeme de signal
  [QT] connect(this->gate, _connected, this, _connected)
  [Elle] dans gate, Register("suce", Parameters<...>);
  [Elle] this->gate.Attach("suce", Callback(...));
  [Elle] this->gate.Signal("suce", parameters);

- dump Channel (call by Gate/Door)
- meme chose avec Socket.

- trouver un terme pour remplacer Address dans elle

- changer le protocole pour que les passports soient echanges car pour
  l'instant label = h(IP)

- passer alpha en prototype: rajouter un tag (cote serveur)

- renommer Node en Host dans remote.

- shrub: faire des listes pour les meme timestamps dans queue
- make: Warning: File `Makefile' has modification time 3557 s in the future

- refaire marcher diary::record -> record make de linux (sans la copie)
- virer diary/ de pig et mettre dans 8diary. si lance avec option
  infinit, on link avec infinit et on bande.

- note that the data modifications should probably update the object's data as well such as the size, timestamps etc. so that, say, a file being opened, modified and reopened in order to get the current size returns the new size instead of the "current" one. => quand on fait un Information, si data have been modified, make it consistent
- passer les versions en 64-bit car un script qui update un fichier toutes les secondes -> vite fait le tour!

#
# ---------- long-term --------------------------------------------------------
#

- pour le locking il faudrait deja faire en sorte que plusieurs scope
  reference un context. comme ca on lockera le contexte a partir d'un
  scope, rendant les autres scopes unusable.

- dans wall faire Transaction puis Apply. difference entre des ref
  en live et normal lorsqu'on l'extract
- peut etre attacher des objects a une fibre: report, session ou autre.
  comment ca pas besoin de govern.

- error si on destroy avec des modifs: comme ca si deux ouvertures et
  un fait des modifs et ensuite se retract ben on peut faire une erreur.

- pourquoi il reste autant de blocks
  => un repertoire est mis a jour N fois puis est Destroy
  => Destroy vire les Objects pour les N versions et les derniers blocks
     de data. il reste donc N blocs de data!

- timeout dans les sockets: en sychone le WaitForReadyRead a un timeout
  par default de 30s alors qu'en asynchrone on fait Fiber::Wait qui
  est infini => le Fiber::Wait devrait prendre un timeout.

- ameliorer le replay: quand on avance jusqu'au from, activer un flag. si
  le flag est active, ne pas appeler FUSE mais quand meme gerer Live.

- copier video -> ca chie et Infinit passe a 480 Mo de RAM!
  => ca doit marcher et avec peu de RAM => plante car block Data trop gros
  => il faudrait decouper!

- utiliser une bsddb ou autre bref une DB local plutot que de stocker les blocs
  dans le FS car pas optimise pour ca => ca devrait ameliorer les perfs.

- rajouter des timeouts sur les I/Os, sur les sockets etc.
