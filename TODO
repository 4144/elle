- passer les appels de Wall avec des pointeurs: on changera dans
  Serialize pour traiter les pointers et les dereferencer
- ticket: file gaps with map of regions
- pour eviter concurrence dans Live, ajouter le pointeur de fi plutot
  que le path.
- rendre tous les IO asynchrone. File::Read etc.
- ticker PIG Missing Functionalities: lock, statefs, fsync, sync, flush etc.

- peut etre passer le recording/replaying en event-based: mieux pour quitter

- utiliser Configuration::Debug::PIG
- changer midget pour qu'il prenne autre chose qu'un Object, c'est pas
  beau. ca devrait prendre un uniquable mais c'est la merde. -> faire une
  fonction a l'instar des std::hex etc.
- ecrire applications/8diary

- dans wall faire Transaction puis Apply. difference entre des ref
  en live et normal lorsqu'on l'extract
- generer des vraies addresses aleatoires: hash -> suffit d'utiliser
  le digest dans sa forme string vu que ca prend en compte family, component
  etc.
- peut etre attacher des objects a une fibre: report, session ou autre.
  comment ca pas besoin de govern.
- ajouter un Serialize(T*) qui serialize le derefenrecement *T.
  ce sera utile pour retourner des pointeurs par reseau.
- changer les yield etc. bref ceux qui ne renvoie pas d'erreur en un log

- utiliser les rvalue references
- passer aux exceptions au lieu de tous les if? on aurait moins de messages
  d'erreurs. on pourrait etre plus precis et ca fera moins a traduire.
  -> ATTENTION: tout d'abord verifier qu'on peut recuperer une stack trace.
- pour optimiser et simplifier, on pourrait merger Access::Grant et
  Access::Update
- prendre en compte gear/State.hh
- revoir midget: autre nom!
- faire marcher cache path, cache block, reserve et journal
  en cherchant le bloc dedans

- peut etre inutile d'avoir un etoile/misc/Information et recuperer l'objet
  entierement dans PIG.
- lock: locker le reseau mais egalement etre sur qu'aucun scope ne travaille
  sur cet objet
- hole/implementations/, hole/algorithms/ etc.

- tree-based data structure -> would improve long directories etc.

                struct fuse_intr_data d;

                dh->len = 0;
                dh->error = 0;
                dh->needlen = size;
                dh->filled = 1;
                dh->req = req;

    dh devient le void* buf du readdir

static int fill_dir(void *dh_, const char *name, const struct stat *statp,
                    off_t off)
{
        struct fuse_dh *dh = (struct fuse_dh *) dh_;
        struct stat stbuf;
        size_t newlen;

        if (statp)
                stbuf = *statp;
        else {
                memset(&stbuf, 0, sizeof(stbuf));
                stbuf.st_ino = FUSE_UNKNOWN_INO;
        }

        if (!dh->fuse->conf.use_ino) {
                stbuf.st_ino = FUSE_UNKNOWN_INO;
                if (dh->fuse->conf.readdir_ino) {
                        struct node *node;
                        pthread_mutex_lock(&dh->fuse->lock);
                        node = lookup_node(dh->fuse, dh->nodeid, name);
                        if (node)
                                stbuf.st_ino  = (ino_t) node->nodeid;
                        pthread_mutex_unlock(&dh->fuse->lock);
                }
        }

        if (off) {
                if (extend_contents(dh, dh->needlen) == -1)
                        return 1;

                dh->filled = 0;
                newlen = dh->len +
                        fuse_add_direntry(dh->req, dh->contents + dh->len,
                                          dh->needlen - dh->len, name,
                                          &stbuf, off);
                if (newlen > dh->needlen)
                        return 1;
        } else {
                newlen = dh->len +
                        fuse_add_direntry(dh->req, NULL, 0, name, NULL, 0);
                if (extend_contents(dh, newlen) == -1)
                        return 1;

                fuse_add_direntry(dh->req, dh->contents + dh->len,
                                  dh->size - dh->len, name, &stbuf, newlen);
        }
        dh->len = newlen;
        return 0;
}
