#!/usr/bin/env python3
# -*- python -*-

import io
import os
import re
import sys
import stat
import copy
import time
import email
import runpy
import pprint
import argparse
import datetime
import threading
import email.mime
import smtplib as sml
import subprocess as sp
import pygooglechart as pgc

from higgs import pool
from higgs import infinitools
from higgs import watchers
from higgs.watchers import StatusCode
from collections import namedtuple
from collections import OrderedDict

pattern = re.compile(r"(?P<name>.*)\.(?P<nb>\d+)\.(?P<ext>py|sh)")

import platform

os.environ['INFINIT_RANDOM_SOURCE'] = '/dev/urandom'

BUILD = os.environ.get(
    'DIR_BUILD',
    os.path.join(
        os.path.abspath(os.path.dirname(__file__)),
        '../build/',
        platform.system().lower() + platform.architecture()[0][:2]
    )
)

SOURCE = os.environ.get(
    'DIR_SOURCE',
    os.path.join(
        os.path.abspath(os.path.dirname(__file__)),
        '../source/'
    )
)

WATCHERS = (
        watchers.Timing,
        watchers.Environ,
        watchers.Result,
        watchers.Memory,
        watchers.Graph,
    )

def functionals_tests(scriptdir, report, scripts_to_run=None):
    with pool.PoolEngine(low_port=5656, high_port=5660) as engine:

        report["engine"] = OrderedDict()
        engine_report = report["engine"]
        report["scripts"] = OrderedDict()

        # Fill the engine report
        engine_report["home"] = engine._base.home
        engine_report["user"] = engine._base.user
        engine_report["mode"] = engine._base.mode
        engine_report["network"] = engine._base.network
        engine_report["conf"] = engine._base.conf.to_dict()

        l_watchers = []

        os.environ["PYTHONPATH"] = scriptdir

        for root, dirs, scripts in os.walk(scriptdir):
            for script in scripts:
                m = pattern.match(script)
                if m == None:
                    print("file", script, "name don't match the specification")
                    continue

                script_data = m.groupdict()

                nb_instance = int(script_data["nb"])
                script_name = script_data["name"]

                if scripts_to_run != None and not script_name in scripts_to_run:
                    continue

                report["scripts"][script_name] = OrderedDict()
                script_report = report["scripts"][script_name]

                script_path = os.path.join(root, script)
                script_report["Script path"] = script_path

                # Skip the script if it's not executable
                if not os.stat(script_path)[stat.ST_MODE] & stat.S_IXUSR:
                    script_report["Error"] = "The script is not executable"
                    script_report["result"] = "FAILURE"
                    continue

                script_report["Number of peers"] = nb_instance

                print("launch the test [\033[32m", script_name,
                        "\033[0m] with",
                        nb_instance, "instances")
                with pool.Pool(engine, number_of_networks=nb_instance) as p:

                    # Fill the report for the networks used by the script
                    script_report["home"] = OrderedDict()
                    home_report = script_report["home"]

                    for i, H in enumerate(p.l_home):
                        home_report["home[{0}]".format(i)] = OrderedDict()
                        curr_rep = home_report["home[{0}]".format(i)]
                        curr_rep["home"] = H.home
                        curr_rep["user"] = H.user
                        curr_rep["conf"] = H.conf.to_dict()
                        curr_rep["network"] = H.network
                        curr_rep["mode"] = H.mode

                        # Dump the .set files
                        with open(os.path.join(
                                H.home,
                                "networks",
                                H.network,
                                "{net}.set".format(net=H.network)), "r") \
                        as setfile:
                            curr_rep["set"] = setfile.read().split()


                    # Prepare the Watchers for this test
                    l_watchers = list(type(script_name, report["scripts"]) for type in WATCHERS)

                    # Save the environ to add some stuff inside
                    environ_save = copy.deepcopy(os.environ)

                    # Wait for the mountpoints to be ready
                    p.wait_ready()
                    print("\033[32mAll the filesystems are effectivly mounted, start the testing...\033[0m")

                    # The scripts needs MNT$i variables to point to the
                    # mountpoints
                    for (i, mountpoint) in enumerate(p.mountpoints):
                        os.environ["MNT{0}".format(i + 1)] = mountpoint
                        print("export MNT{0}={1}".format(i + 1, mountpoint))

                    for (i, pid) in enumerate(p.pids):
                        os.environ["INFINIT_PID{0}".format(i + 1)] = str(pid)

                    for W in l_watchers: W.pre_run(os.environ)

                    s = StatusCode()

                    out, err = "", ""
                    try:
                        p1 = sp.Popen([script_path], stdout=sp.PIPE, stderr=sp.PIPE)
                        out, err = p1.communicate()
                        if p1.returncode == 0:
                                s.status = StatusCode.SUCCESS
                                print("\033[32mtest", script_name,"success\033[0m")
                        else:
                                s.status = StatusCode.FAILURE
                                print("\033[31mtest", script_name,"failed\033[0m")
                    except BaseException as e:
                        s.status = StatusCode.FAILURE
                        print(e)
                        script_report["Reason"] = str(e)
                        print("\033[31mtest", script_name,"failed\033[0m")
                    finally:
                        if "std" not in script_report:
                            script_report["std"] = OrderedDict()
                        script_report["std"]["out"] = out.decode("utf8")
                        script_report["std"]["err"] = err.decode("utf8")
                        for W in l_watchers: W.post_run(s)
                    os.environ.update(environ_save)
        for W in l_watchers: W.post_shutdown(report)
        return all(test["result"] == "SUCCESS" for test in report["scripts"].values())


def unit_tests(report):
    report["unit_tests"] = OrderedDict()
    ret = True
    out, err = "", ""
    try:
        s1 = sp.Popen(["make", "test"], cwd=BUILD, stdout=sp.PIPE, stderr=sp.PIPE)
        out, err = s1.communicate()
        print(out.decode("utf8"))
        print(err.decode("utf8"))
    except Exception as e:
        print(e)
        ret = False
    finally:
        report["unit_tests"]["stdout"] = out.decode("utf8")
        report["unit_tests"]["stderr"] = err.decode("utf8")
    return ret

def clean_the_fuck_up():
    """
    For some reasons, infinit does not clean itself correctly.

    We know that we create the dirs in /tmp/infinit.*
    """

    # Shut the fuck up
    sp.call(['sudo', 'pkill', '-9', '8infinit'])

    mount_p = sp.Popen(['sudo', 'mount',
        '-t', 'fuse.infinit'], stdout=sp.PIPE)

    cut_p = sp.Popen(['cut',
        '-d', ' ',
        '-f', '3'], stdin=mount_p.stdout, stdout=sp.PIPE)
    mount_p.stdout.close()
    mountpoints = cut_p.communicate()[0].split()
    if mountpoints:
        sp.call([b'sudo', b'umount'] + mountpoints)
    sp.call('rm -rf /tmp/infinit.*', shell=True)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run the infinit test suite")

    parser.add_argument('--scriptdir', '-d', metavar="DIR",
            default=os.path.join(SOURCE, "tests", "functional", "scripts"),
            help="the dir containing the scripts to be run")

    parser.add_argument('--scripts', '-s',
            help="the scripts to be run")

    parser.add_argument('--source ', '-r', default=SOURCE,
            help="the source directory")

    parser.add_argument('--builddir', '-b', default=BUILD,
            help="the build directory containing the binaries")

    args = parser.parse_args()

    # Update the env and paths for compatibility purpose
    os.environ["INFINIT_BUILD"] = args.builddir
    infinitools.patch_satellites_path(args.builddir)
    
    report = OrderedDict()
    # Run the functionals tests
    if not args.scripts:
        res = functionals_tests(args.scriptdir, report)
    else:
        res = functionals_tests(args.scriptdir, report, args.scripts.split(","))

    # Run the unit tests
    if unit_tests(report) == False:
        res = False

    with open("report", "w") as reportfile:
        import pprint
        pprint.pprint(report, stream=reportfile)

    m = watchers.Mail()
    m.send_mail(report)

    if not res:
        sys.exit(1)
