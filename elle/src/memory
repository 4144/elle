// -*- c++ -*-
#ifndef ELLE_MEMORY
# define ELLE_MEMORY

# include_next <cassert>
# include_next <memory>

namespace std
{
  template<typename T, typename U, typename D>
  std::unique_ptr<T, D>
  static_pointer_cast(std::unique_ptr<U, D>& p)
  {
    return static_pointer_cast<T>(std::move(p));
  }

  template<typename T, typename U, typename D>
  std::unique_ptr<T, D>
  static_pointer_cast(std::unique_ptr<U, D>&& p)
  {
    assert(
      dynamic_cast<typename std::unique_ptr<T>::element_type*>(p.get()));
    auto raw =
      static_cast<typename std::unique_ptr<T>::element_type*>(p.release());
    return std::unique_ptr<T, D>(raw, p.get_deleter());
  }

  template<typename T, typename U>
  std::unique_ptr<T>
  static_pointer_cast(std::unique_ptr<U>&& p)
  {
    assert(
      dynamic_cast<typename std::unique_ptr<T>::element_type*>(p.get()));
    auto raw =
      static_cast<typename std::unique_ptr<T>::element_type*>(p.release());
    return std::unique_ptr<T>(raw);
  }

  template<typename T, typename U, typename D>
  std::unique_ptr<T, D>
  dynamic_pointer_cast(std::unique_ptr<U, D>& p)
  {
    return dynamic_pointer_cast<T>(std::move(p));
  }

  template<typename T, typename U, typename D>
  std::unique_ptr<T, D>
  dynamic_pointer_cast(std::unique_ptr<U, D>&& p)
  {
    auto raw =
      dynamic_cast<typename std::unique_ptr<T>::element_type*>(p.get());
    if (raw)
      p.release();
    return std::unique_ptr<T, D>(raw, p.get_deleter());
  }

  template<typename T, typename U>
  std::unique_ptr<T>
  dynamic_pointer_cast(std::unique_ptr<U>&& p)
  {
    auto raw =
      dynamic_cast<typename std::unique_ptr<T>::element_type*>(p.get());
    if (raw)
      p.release();
    return std::unique_ptr<T>(raw);
  }

  /** Make a shared pointer to an object.
   *
   *  This this helper
   */
  template<typename T>
  std::shared_ptr<T>
  make_shared(T&& o)
  {
    return std::make_shared<T, T&&>(std::forward<T>(o));
  }

  template <typename T>
  class ambivalent_ptr
    : public weak_ptr<T>
  {
  public:
    using weak_ptr<T>::weak_ptr;
    using weak_ptr<T>::operator =;
    ambivalent_ptr()
      : weak_ptr<T>()
      , _payload()
    {}

    explicit
    ambivalent_ptr(T* ptr)
      : weak_ptr<T>()
      , _payload(ptr)
    {
      *this = this->_payload;
    }

    template <typename Y>
    explicit
    ambivalent_ptr(Y* ptr)
      : weak_ptr<T>()
      , _payload(ptr)
    {
      *this = this->_payload;
    }

    std::shared_ptr<T>&
    payload()
    {
      return this->_payload;
    }

    std::shared_ptr<T> const&
    payload() const
    {
      return this->_payload;
    }
  private:
    std::shared_ptr<T> _payload;
  };
}

#endif
