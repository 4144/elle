//
// ---------- header ----------------------------------------------------------
//
// project       elle
//
// license       infinit
//
// author        julien quintard   [mon mar  8 23:05:41 2010]
//

//
// ---------- macro-functions -------------------------------------------------
//

///
/// these macro functions are used to make using the Elle library
/// functionalities easier.
///

//
// ---------- includes --------------------------------------------------------
//

///
/// first includes Close.hh in order to undeclare everything.
///
#include <elle/idiom/Close.hh>

//
// ---------- dependencies ----------------------------------------------------
//

#include <cstdio>

#include <elle/types.hh>

//
// ---------- elle ------------------------------------------------------------
//

///
/// this macro function is sometimes use to group several parameter which
/// can be pretty useful when a parameter contains a comma for instance.
///
#define _(...)                                                          \
  __VA_ARGS__

//
// ---------- meta ------------------------------------------------------------
//

///
/// this macro function enables the programmer to define compile-time
/// assertions.
///
#define allege(_condition_)                                             \
  do                                                                    \
    {                                                                   \
      elle::radix::Allege<(_condition_)>();                             \
    } while (0)

//
// ---------- object ----------------------------------------------------------
//

///
/// this macro generates the prototypes for the fundamental object
/// method.
///
/// for more information please refer to radix/Object.hh
///
#define declare(_type_)                                                 \
  _type_&               operator=(const _type_&);                       \
                                                                        \
  elle::Boolean   operator!=(const _type_&) const;                \
                                                                        \
  elle::Boolean   operator<=(const _type_&) const;                \
                                                                        \
  elle::Boolean   operator>=(const _type_&) const;                \
                                                                        \
  elle::Status   Imprint(elle::Natural32&) const;          \
                                                                        \
  elle::Status   Clone(elle::radix::Object*&)                    \
    const;

///
/// this macro function makes it easy for classes to derive from Object
/// as only a copy constructor and some operators such as ==, <, > etc.
/// must be manually written, should the class need to provide such
/// operators.
///
/// everything else, assignment, != operator, sizeof etc. are automatically
/// generated by the following.
///
#define embed(_type_, _template_)                                       \
  _template_                                                            \
  _type_&       _type_::operator=(const _type_&         object)         \
  {                                                                     \
    /*enter();*/                                                            \
                                                                        \
    if (this == &object)                                                \
      return (*this);                                                   \
    if (this->Recycle(&object) == elle::Status::Error)             \
      yield(*this, "unable to recycle the object");                     \
                                                                        \
    return (*this);                                                     \
  }                                                                     \
                                                                        \
  _template_                                                            \
  elle::Boolean   _type_::operator!=(const _type_& object) const  \
  {                                                                     \
    return (!(this->operator==(object)));                               \
  }                                                                     \
                                                                        \
  _template_                                                            \
  elle::Boolean   _type_::operator<=(const _type_& object) const  \
  {                                                                     \
    return ((this->operator<(object) || this->operator==(object)));     \
  }                                                                     \
                                                                        \
  _template_                                                            \
  elle::Boolean   _type_::operator>=(const _type_& object) const  \
  {                                                                     \
    return ((this->operator>(object) || this->operator==(object)));     \
  }                                                                     \
                                                                        \
  _template_                                                            \
  elle::Status   _type_::Imprint(elle::Natural32& size)    \
    const                                                               \
  {                                                                     \
                                                                        \
    size = sizeof (_type_);                                             \
                                                                        \
    return elle::Status::Ok;                                       \
  }                                                                     \
                                                                        \
  _template_                                                            \
  elle::Status   _type_::Clone(                                  \
                          elle::radix::Object*&                         \
                            object)                                     \
    const                                                               \
  {                                                                     \
    object = new _type_(*this);                                         \
                                                                        \
    return elle::Status::Ok;                                       \
  }

//
// ---------- log -------------------------------------------------------------
//

///
/// this macro-function registers a log entry.
///
#define log(_format_, ...)                                              \
  do                                                                    \
    {                                                                   \
      elle::standalone::Log*    _log_;                                  \
      std::ostringstream        _tmp_;                                  \
      elle::Character     _message_[1024];                        \
                                                                        \
      _tmp_ << __FILE__ << ":" << __LINE__ << " # " << __FUNCTION__;    \
                                                                        \
      elle::String        _location_(_tmp_.str());                \
      elle::String        _time_(__DATE__ " " __TIME__);          \
                                                                        \
      ::sprintf(_message_, _format_, ##__VA_ARGS__);                    \
                                                                        \
      if (elle::standalone::Log::Instance(_log_) ==                     \
          elle::Status::True)                                      \
        _log_->Record(_location_,                                       \
                      _time_,                                           \
                      elle::String(_message_));                   \
      else                                                              \
        {                                                               \
          std::cerr << _message_                                        \
                    << " (" << _location_ << ") @ "                     \
                    << _time_ << std::endl;                             \
                                                                        \
          show();                                                       \
        }                                                               \
    } while (false)

//
// ---------- report ----------------------------------------------------------
//

///
/// this macro-function registers a report entry.
///
/// note that this macro function should seldomly be called directly. instead
/// the macro functions below should be used: leave, escape, true
/// etc.
///
#define report(_format_, ...)                                           \
  do                                                                    \
  {                                                                     \
    std::ostringstream        _tmp_;                                    \
    elle::Character     _message_[1024];                                \
                                                                        \
    _tmp_ << __FILE__ << ":" << __LINE__ << " # " << __FUNCTION__;      \
                                                                        \
      elle::String        _location_(_tmp_.str());                      \
      elle::String        _time_(__DATE__ " " __TIME__);                \
                                                                        \
    ::sprintf(_message_, _format_, ##__VA_ARGS__);                      \
                                                                        \
    elle::standalone::Report::report.Get().Record(_location_,           \
                                      _time_,                           \
                                      elle::String(_message_));         \
  } while (false)                                                       \

///
/// this macro-function transposes an existing report.
///
#define transpose(_r_)                          \
  elle::standalone::Report::report.Get().Record(_r_)

///
/// this macro-function indicates that an error occured
/// and returns Status::Error.
///
#define escape(_format_, ...)                                           \
  do                                                                    \
    {                                                                   \
      report(_format_, ##__VA_ARGS__);                                  \
                                                                        \
      return (elle::Status::Error);                                     \
    } while (false)                                                     \

///
/// this macro-function logs the fact that an error occured
/// and returns Status::False.
///
#define flee(_format_, ...)                                             \
  do                                                                    \
    {                                                                   \
      log(_format_, ##__VA_ARGS__);                                     \
                                                                        \
      return (elle::Status::False);                                \
    } while (false)                                                     \

///
/// this macro-function logs an error and returns.
///
/// note that the return object is specifed, hence this function
/// perfectly fits when an error occurs in operators for instance.
///
/// note that no parentheses are put around _return_ in case it
/// would be empty.
///
#define yield(_return_, _format_, ...)                                  \
  do                                                                    \
    {                                                                   \
      log(_format_, ##__VA_ARGS__);                                     \
                                                                        \
      return _return_;                                                  \
    } while (false)

///
/// this macro-function adds an failure, displays the stack and
/// stops the program.
///
/// this macro-function is especially useful in constructors.
///
#define fail(_format_, ...)                                             \
  do                                                                    \
  {                                                                     \
    report(_format_, ##__VA_ARGS__);                                    \
                                                                        \
    show();                                                             \
                                                                        \
    ::exit(EXIT_FAILURE);                                               \
  } while (false)

///
/// this macro-function displays the error stack on the error output.
///
#define show()                                                          \
  do                                                                    \
    {                                                                   \
      elle::standalone::Report& _report_ =                              \
        elle::standalone::Report::report.Get();                         \
                                                                        \
      _report_.Dump();                                                  \
      _report_.Flush();                                                 \
    } while (false)                                                     \

///
/// this macro-function, in the case of reported errors, displays them
/// and exits. otherwise, the function does not do anything.
///
#define expose()                                                        \
  do                                                                    \
    {                                                                   \
      elle::standalone::Report& _report_ =                              \
        elle::standalone::Report::report.Get();                         \
      if (_report_.container.empty() == false)                          \
      {                                                                 \
        _report_.Dump();                                                \
        _report_.Flush();                                               \
        ::exit(EXIT_FAILURE);                                           \
      }                                                                 \
    } while (false)

///
/// this macro-function flushes all the recorded messages.
///
#define purge()                                                         \
  do                                                                    \
    {                                                                   \
      elle::standalone::Report::report.Get().Flush();                   \
    } while (false)

//
// ---------- morgue ----------------------------------------------------------
//

///
/// this macro function can be used to delay the deletion of an instance.
///
/// this is useful for instance for deleting a timer if we are in
/// a callback which has been triggered by it. deleting the timer right
/// away could lead to crashes since, following the deletion, the code
/// executed would still belong to the timer.
///
#define bury(_instance_)                                                \
  do                                                                    \
    {                                                                   \
      elle::standalone::Morgue* _morgue_;                               \
                                                                        \
      if (elle::standalone::Morgue::Instance(_morgue_) ==               \
          elle::Status::True)                                      \
        {                                                               \
          if (_morgue_->Register(_instance_) ==                         \
              elle::Status::Error)                                 \
            log("unable to register the instance for burial");          \
        }                                                               \
    } while (false)

//
//
// ---------- message ---------------------------------------------------------
//

///
/// this macro-function defines an inward message part of the
/// interface.
///
#define inward(_tag_, _parameters_)                                     \
  message(_tag_, parameters(_parameters_))

///
/// this macro-function defines an outward message i.e response
/// to a previously received inward message.
///
#define outward(_tag_, _parameters_)                                    \
  message(_tag_, parameters(_parameters_))

///
/// this macro defines a message.
///
#define message(_tag_, _parameters_)                                    \
  namespace elle                                                        \
  {                                                                     \
    using namespace radix;                                              \
                                                                        \
    namespace network                                                   \
    {                                                                   \
      template <>                                                       \
      class Message< _tag_ >:                                           \
        public Entity                                                   \
      {                                                                 \
      public:                                                           \
        static const Tag                        G = _tag_;              \
                                                                        \
        typedef Parameters<_parameters_ >      P;                       \
                                                                        \
        struct                                  B                       \
        {                                                               \
          typedef Bundle::Inputs<G,                                     \
                                 typename                               \
                                   Trait::Constant<                     \
                                     P                                  \
                                   >::Type                              \
                                 >              Inputs;                 \
          typedef Bundle::Outputs<G, P>         Outputs;                \
        };                                                              \
      };                                                                \
    }                                                                   \
  }

///
/// syntaxic sugar.
///
#define parameters(...)                                                 \
  __VA_ARGS__

//
// ---------- network ---------------------------------------------------------
//

///
/// this macro-function reserves a range of _capacity_ tags for the
/// _component_ which depends upon the _dependencies_ components.
///
#define range(_component_, _capacity_, ...)                             \
  namespace elle                                                        \
  {                                                                     \
    namespace network                                                   \
    {                                                                   \
      template <>                                                       \
      struct Range<_component_>:                                        \
        public Capacity<_capacity_>                                     \
      {                                                                 \
        static const int                First =                         \
          Dependency<__VA_ARGS__>::Last + 1;                            \
        static const int                Last = First + Size;            \
      };                                                                \
    }                                                                   \
  }

