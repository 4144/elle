import drake
import drake.cxx
import drake.cxx.boost
import drake.valgrind
import sys
import os


config = None
lib_static = None
lib_dynamic = None
library = None
library_zlib = None

rule_build = None
rule_check = None
rule_install = None
rule_tests = None

# XXX
with open(str(drake.path_source('../drake-utils.py')), 'r') as f:
  exec(f.read(), globals(), globals())

def configure(cxx_toolkit = None,
              cxx_config = None,
              boost = None,
              enable_tests = True,
              prefix = '/usr',
              valgrind = None):

  global config, lib_static, lib_dynamic, library, library_zlib
  global rule_build, rule_check, rule_install, rule_tests

  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()
  cxx_config = cxx_config or drake.cxx.Config()

  boost = boost or drake.cxx.boost.Boost()

  cxx_config += boost.config()
  cxx_config += boost.config_filesystem(static = (cxx_toolkit.os is drake.os.macos or None))
  cxx_config += boost.config_system()
  cxx_config += boost.config_thread()
  cxx_config += boost.config_chrono()
  cxx_config += boost.config_iostreams()

  config = drake.cxx.Config()
  config.standard = drake.cxx.Config.cxx_11
  config.add_local_include_path('src')
  config.lib_path('lib')
  config.define('BOOST_PP_VARIADICS')
  config.define('BOOST_FILESYSTEM_NO_DEPRECATED', '1')

  # OS
  if cxx_toolkit.os == drake.os.linux:
    config.define('INFINIT_LINUX')
  elif cxx_toolkit.os == drake.os.macos:
    config.define('INFINIT_MACOSX')
  elif cxx_toolkit.os == drake.os.windows:
    config.define('INFINIT_WINDOWS')
    config.lib('Shlwapi')
    config.lib('ws2_32')
  else:
    raise Exception('unsupported os')

  #Zlib
  zlib_version = '1.2.8'
  zlib_basename = 'zlib-%s' % zlib_version
  zlib_tarball = drake.node('zlib/%s.tar.gz' % zlib_basename)
  zlib_root = drake.Path('zlib') / zlib_basename
  # This url does not work due to Apache that messes up with content-type headers
  # zlib_url = 'http://zlib.net/%s.tar.gz' % zlib_basename
  zlib_url = 'http://downloads.sourceforge.net/project/libpng/zlib/%s/%s.tar.gz' % (
    zlib_version,
    zlib_basename,
  )
  drake.HTTPDownload(
    zlib_url,
    zlib_tarball,
    fingerprint = '44d667c142d7cda120332623eab69f40'
  )
  drake.TarballExtractor(
    zlib_tarball,
    targets = ['%s/%s' % (zlib_basename, 'configure')],
  )
  zlib_prefix = drake.path_build('zlib')

  library_zlib = drake.cxx.StaticLib('zlib/lib/libz.a')
  zlib_libs = [library_zlib,]

  if cxx_toolkit.os is drake.os.windows:
    # XXX only for mingw
    zlib_makefile = 'win32/Makefile.gcc'
    zlib_configure = None
  else:
    zlib_makefile = None
    zlib_configure = drake.node(zlib_root / 'configure')

  GNUBuilder(
    cxx_toolkit,
    configure = zlib_configure,
    configure_args = [
      '--prefix=%s/%s' % (os.getcwd(), zlib_prefix),
      '--static',
    ],
    additional_env = {
      'CFLAGS': '-fPIC',
    },
    working_directory = drake.path_build(zlib_root),
    targets = zlib_libs + [drake.node('zlib/include/zlib.h')],
    makefile = zlib_makefile,
    sources = [drake.node(zlib_root / 'configure'),],
    build_args = ['install'] + list(s.replace('\\', '/') for s in [
      "INCLUDE_PATH='%s/%s/include'" % (os.getcwd(), zlib_prefix),
      "BINARY_PATH='%s/%s/bin'" % (os.getcwd(), zlib_prefix),
      "LIBRARY_PATH='%s/%s/lib'" % (os.getcwd(), zlib_prefix),
      #"SHARED_MODE=1",
    ])
  )
  zlib_libs = drake.copy(zlib_libs, '.', 'zlib')
  zlib_config = drake.cxx.Config()
  zlib_config.add_local_include_path('zlib/include')

  config += zlib_config

  # XXX[for fuse only]
  config.define('HAVE_SETXATTR')

  # XXX[for fuse only]
  if cxx_toolkit.os == drake.os.macos:
    config.define('HAVE_STATFS')

  cxx_config = cxx_config + config

  sources = drake.nodes(
    'src/elle/finally.cc',
    'src/elle/finally.hh',
    'src/elle/AtomicFile.cc',
    'src/elle/AtomicFile.hh',
    'src/elle/Backtrace.cc',
    'src/elle/Backtrace.hh',
    'src/elle/Buffer.cc',
    'src/elle/Buffer.hh',
    'src/elle/Exception.cc',
    'src/elle/Exception.hh',
    'src/elle/HttpClient.cc',
    'src/elle/HttpClient.hh',
    'src/elle/IOStream.cc',
    'src/elle/IOStream.hh',
    'src/elle/Lazy.hh',
    'src/elle/Lazy.hxx',
    'src/elle/Printable.cc',
    'src/elle/Printable.hh',
    'src/elle/Version.cc',
    'src/elle/assert.cc',
    'src/elle/assert.hh',
    'src/elle/compiler.hh',
    'src/elle/concept/Fileable.hh',
    'src/elle/concept/Fileable.hxx',
    'src/elle/concept/Uniquable.hh',
    'src/elle/concept/Uniquable.hxx',
    'src/elle/concept/fwd.hh',
    'src/elle/container/fwd.hh',
    'src/elle/container/timeline/Bucket.hh',
    'src/elle/container/timeline/Bucket.hxx',
    'src/elle/container/timeline/Timeline.hh',
    'src/elle/container/timeline/Timeline.hxx',
    'src/elle/container/timeline/fwd.hh',
    'src/elle/elle.hh',
    'src/elle/container/initializer_list.hxx',
    'src/elle/container/initializer_list.hh',
    'src/elle/container/list.hxx',
    'src/elle/container/list.hh',
    'src/elle/container/map.hxx',
    'src/elle/container/map.hh',
    'src/elle/container/set.hxx',
    'src/elle/container/set.hh',
    'src/elle/container/vector.hxx',
    'src/elle/container/vector.hh',
    'src/elle/string/algorithm.hh',
    'src/elle/string/algorithm.hxx',
    'src/elle/format/fwd.hh',
    'src/elle/format/hexadecimal.cc',
    'src/elle/format/hexadecimal.hh',
    'src/elle/format/base64.cc',
    'src/elle/format/base64.hh',
    'src/elle/format/base64url.cc',
    'src/elle/format/base64url.hh',
    'src/elle/format/base64url.hxx',
    'src/elle/format/gzip.cc',
    'src/elle/format/gzip.hh',
    #'src/elle/format/lzo.cc',
    #'src/elle/format/lzo.hh',
    'src/elle/format/ini/File.cc',
    'src/elle/format/ini/File.hh',
    'src/elle/format/ini/Section.cc',
    'src/elle/format/ini/Section.hh',
    'src/elle/format/ini/Section.hxx',
    'src/elle/format/ini/fwd.hh',
    'src/elle/format/json.hh',
    'src/elle/format/json/Array.cc',
    'src/elle/format/json/Array.hh',
    'src/elle/format/json/Array.hxx',
    'src/elle/format/json/Bool.cc',
    'src/elle/format/json/Bool.hh',
    'src/elle/format/json/Dictionary.cc',
    'src/elle/format/json/Dictionary.hh',
    'src/elle/format/json/Dictionary.hxx',
    'src/elle/format/json/Factory.cc',
    'src/elle/format/json/Factory.hh',
    'src/elle/format/json/Factory.hxx',
    'src/elle/format/json/Float.cc',
    'src/elle/format/json/Float.hh',
    'src/elle/format/json/Integer.cc',
    'src/elle/format/json/Integer.hh',
    'src/elle/format/json/Null.cc',
    'src/elle/format/json/Null.hh',
    'src/elle/format/json/Object.cc',
    'src/elle/format/json/Object.hh',
    'src/elle/format/json/Object.hxx',
    'src/elle/format/json/Parser.cc',
    'src/elle/format/json/Parser.hh',
    'src/elle/format/json/String.cc',
    'src/elle/format/json/String.hh',
    'src/elle/format/json/_detail.hh',
    'src/elle/format/json/fwd.hh',
    'src/elle/fwd.hh',
    'src/elle/io/Console.cc',
    'src/elle/io/Console.hh',
    'src/elle/io/Dumpable.cc',
    'src/elle/io/Dumpable.hh',
    'src/elle/io/Path.cc',
    'src/elle/io/Path.hh',
    'src/elle/io/Path.hxx',
    'src/elle/io/Pattern.cc',
    'src/elle/io/Pattern.hh',
    'src/elle/io/Piece.cc',
    'src/elle/io/Piece.hh',
    'src/elle/io/Unique.hh',
    'src/elle/io/fwd.hh',
    'src/elle/log.hh',
    'src/elle/log/Logger.cc',
    'src/elle/log/Logger.hh',
    'src/elle/log/Send.cc',
    'src/elle/log/Send.hh',
    'src/elle/log/Send.hxx',
    'src/elle/log/TextLogger.cc',
    'src/elle/log/TextLogger.hh',
    'src/elle/network/Host.cc',
    'src/elle/network/Host.hh',
    'src/elle/network/Host.hxx',
    'src/elle/network/Interface.cc',
    'src/elle/network/Interface.hh',
    'src/elle/network/Interface.hxx',
    'src/elle/network/Locus.cc',
    'src/elle/network/Locus.hh',
    'src/elle/network/Locus.hxx',
    'src/elle/network/Port.hh',
    'src/elle/network/fwd.hh',
    'src/elle/os.hh',
    'src/elle/os/environ.hh',
    'src/elle/os/environ.cc',
    'src/elle/os/file.hh',
    'src/elle/os/file.cc',
    'src/elle/os/getenv.cc',
    'src/elle/os/getenv.hh',
    'src/elle/os/path.cc',
    'src/elle/os/path.hh',
    'src/elle/os/path.hxx',
    'src/elle/os/setenv.cc',
    'src/elle/os/setenv.hh',
    'src/elle/os/unsetenv.cc',
    'src/elle/os/unsetenv.hh',
    'src/elle/print.cc',
    'src/elle/print.hh',
    'src/elle/print.hxx',
    'src/elle/printf.hh',
    'src/elle/printf.hxx',
    'src/elle/system/system.hh',
    'src/elle/system/platform.hh',
    'src/elle/system/signal.hh',
    'src/elle/system/signal.cc',
    'src/elle/system/getpid.hh',
    'src/elle/system/getpid.cc',
    'src/elle/system/home_directory.cc',
    'src/elle/types.hh',
    )

  sources += drake.nodes(
    'src/elle/serialize/ArchiveMode.cc',
    'src/elle/serialize/ArchiveMode.hh',
    'src/elle/serialize/ArraySerializer.hxx',
    'src/elle/serialize/Base64Archive.cc',
    'src/elle/serialize/Base64Archive.hh',
    'src/elle/serialize/BaseArchive.hh',
    'src/elle/serialize/BaseArchive.hxx',
    'src/elle/serialize/BinaryArchive.hh',
    'src/elle/serialize/BinaryArchive.hxx',
    'src/elle/serialize/Format.hh',
    'src/elle/serialize/HexadecimalArchive.hh',
    'src/elle/serialize/IniArchive.cc',
    'src/elle/serialize/IniArchive.hh',
    'src/elle/serialize/JSONArchive.cc',
    'src/elle/serialize/JSONArchive.hh',
    'src/elle/serialize/JSONArchive.hxx',
    'src/elle/serialize/ListSerializer.hxx',
    'src/elle/serialize/MapSerializer.hxx',
    'src/elle/serialize/PairSerializer.hxx',
    'src/elle/serialize/Pointer.hh',
    'src/elle/serialize/Pointer.hxx',
    'src/elle/serialize/Serializable.hh',
    'src/elle/serialize/Serializable.hh',
    'src/elle/serialize/Serializable.hxx',
    'src/elle/serialize/Serializable.hxx',
    'src/elle/serialize/Serializer.hh',
    'src/elle/serialize/SetSerializer.hxx',
    'src/elle/serialize/StaticFormat.hh',
    'src/elle/serialize/TupleSerializer.hxx',
    'src/elle/serialize/VectorSerializer.hxx',
    'src/elle/serialize/detail/AssociativeSerializer.hh',
    'src/elle/serialize/detail/MergeArchive.hh',
    'src/elle/serialize/detail/SequenceSerializer.hh',
    'src/elle/serialize/detail/stream.hh',
    'src/elle/serialize/detail/stream.cc',
    'src/elle/serialize/extract.cc',
    'src/elle/serialize/extract.hh',
    'src/elle/serialize/extract.hxx',
    'src/elle/serialize/footprint.hh',
    'src/elle/serialize/footprint.hxx',
    'src/elle/serialize/fwd.hh',
    'src/elle/serialize/insert.cc',
    'src/elle/serialize/insert.hh',
    'src/elle/serialize/insert.hxx',
    )

  sources += drake.nodes(
    'src/elle/system/platform.hh',
    'src/elle/system/Process.cc',
    'src/elle/system/Process.hh',
    'src/elle/system/system.hh',
    )

  sources += drake.nodes(
    'src/elle/utility/Duration.cc',
    'src/elle/utility/Duration.hh',
    'src/elle/utility/Duration.hxx',
    #'src/elle/utility/HTTP.cc',
    #'src/elle/utility/HTTP.hh',
    'src/elle/utility/Parser.cc',
    'src/elle/utility/Parser.hh',
    'src/elle/utility/Parser.hxx',
    'src/elle/utility/Product.hh',
    'src/elle/utility/Settings.cc',
    'src/elle/utility/Settings.hh',
    'src/elle/utility/Time.cc',
    'src/elle/utility/Time.hh',
    'src/elle/utility/Time.hxx',
    'src/elle/utility/URI.hh',
    'src/elle/utility/Unicode-unix.cc',
    'src/elle/utility/Unicode.hh',
    'src/elle/utility/Utility.hh',
    'src/elle/utility/fwd.hh',
   )

  lib_static = drake.cxx.StaticLib(
    'lib/elle',
    sources + zlib_libs,
    cxx_toolkit,
    cxx_config
  )
  lib_dynamic = drake.cxx.DynLib(
    'lib/elle',
    sources + zlib_libs,
    cxx_toolkit,
    cxx_config
  )

  rule_build = drake.Rule('build')
  rule_build << lib_static
  if cxx_toolkit.os != drake.os.windows:
    rule_build << lib_dynamic
    library = lib_dynamic
  else:
    library = lib_static

  # Tests

  rule_tests = drake.Rule('tests')
  rule_check = drake.TestSuite('check')

  tests = [
    "attributes.cc",
    "compiler.cc",
    "Backtrace.cc",
    "Buffer.cc",
    "Exception.cc",
    "With.cc",
    "assert.cc",
    "finally.cc",
    "IOStream.cc",
    "log.cc",
    "Lazy.cc",
    "Logger.cc",
    "operator.cc",
    "Printable.cc",
    "print.cc",
    "printf.cc",
    "cast.cc",
    "containers.cc",
    "memory.cc",
    "os/getenv.cc",
    "os/setenv.cc",
    "os/environ.cc",
    "Version.cc",
    "format/base64.cc",
    "format/ini/Section.cc",
    "format/json/Array.cc",
    "format/json/Bool.cc",
    "format/json/Dictionary.cc",
    "format/json/Float.cc",
    "format/json/Integer.cc",
    "format/json/Null.cc",
    "format/json/String.cc",
    "format/gzip.cc",
    "io/Path.cc",
    "io/Piece.cc",
    #"nat/nat_hole_ctor.cc",
    #"nat/nat_hole_punch.cc",
    "network/interface_autoip.cc",
    "network/interface.cc",
    "network/Locus.cc",
    "serialize/all_archives.cc",
    "serialize/Base64Archive.cc",
    "serialize/BinaryArchive.cc",
    "serialize/construct.cc",
    "serialize/JSONArchive.cc",
    "serialize/Pointer.cc",
    "serialize/Serializable.cc",
    "serialize/version_change.cc",
    "serialize/footprint.cc",
    "serialize/extract.cc",
    "system/home_directory.cc",
    "threading/monitor.cc",
    "utility/Suffixes.cc",
    ]

  if cxx_toolkit.os != drake.os.windows:
    tests.extend([
      "AtomicFile.cc",
      "system/process.cc",
      "system/process-args.cc",
      "system/process-fail.cc",
      "system/process-sleep.cc",
      "system/process-kill.cc",
      "system/process-unknow.cc",
      "system/process-unknonw-wait.cc",
      "system/process-output-config.cc",
      "system/process-pipe.cc",
      "system/process-checkoutput.cc",
      "system/process-pipe2.cc",
      "system/process-shortcuts.cc",
      "system/process-pipe-to-file.cc",
    ])

  cxx_config_tests = cxx_config + config
  cxx_config_tests += boost.config_test()
  if enable_tests:
    for test in tests:
      config_test = drake.cxx.Config(cxx_config_tests)
      config_test.lib_path_runtime('%s../lib' % ('../' * test.count('/')))
      test = drake.cxx.Executable('tests/%s' % os.path.splitext(test)[0],
                                  drake.nodes('tests/%s' % test) + [library] + zlib_libs,
                                  cxx_toolkit, config_test)
      rule_tests << test
      if valgrind is not None:
        runner = drake.valgrind.ValgrindRunner(exe = test,
                                               valgrind = valgrind)
      else:
        runner = drake.Runner(exe = test)
      runner.reporting = drake.Runner.Reporting.on_failure
      rule_check << runner.status

  # Install

  rule_install = drake.Rule('install')
  prefix = drake.Path(prefix)
  rule_install << drake.install(lib_dynamic, prefix)
  rule_install << drake.install(lib_static, prefix)
  rule_install << drake.install(
    list(filter(lambda n: isinstance(n, drake.cxx.Header), sources)),
    prefix / 'include', 'src')
