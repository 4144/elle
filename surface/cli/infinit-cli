#!/usr/bin/env python3
# -*- encoding: utf-8 -*-


"""
Infinit launcher for linux.
"""

import argparse
import cmd
import getpass
import os
import re
import stat
import sys

INFINIT_DEFAULT_HOME = os.path.join(
    os.path.expanduser('~'), '.infinit'
)

INFINIT_HOME = os.environ.get('INFINIT_HOME', INFINIT_DEFAULT_HOME)

MANIFEST_URI = "http://download.infinit.im/linux64/manifest.xml"

SHELL_INTRO = """
Welcome to the infinit shell (type help for a list of commands).
"""

EMAIL_REGEXP = re.compile(
    r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*"  # dot-atom
    r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-011\013\014\016-\177])*"' # quoted-string
    r')@(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?$',
    re.IGNORECASE
)

parser = argparse.ArgumentParser(description="Infinit launcher")

parser.add_argument(
    '--register',
    '-r',
    help="Register instead of log in",
    action="store_true"
)

parser.add_argument(
    'action',
    choices=['start', 'stop', 'restart', 'shell'],
    default='start',
    nargs='?',
    help="Action done once logged in",
)

parser.add_argument(
    '--no-update',
    help="Skip the update process",
    action="store_true",
)

class InfinitShell(cmd.Cmd):
    def __init__(self, state, args):
        self._state = state
        self._args = args
        self.prompt = state.email + '$ '
        super(InfinitShell, self).__init__()

    def do_networks(self, args):
        """Print networks."""
        try:
            networks = self._state.networks()
            for network_id in networks:
                print(self._state.network_name(network_id), '(%s)' % network_id)
                mnt = None
                try: mnt = self._state.network_mount_point(network_id)
                except: pass
                print('\t- mount point:', mnt)
        except Exception as e:
            print(e)

    def do_create_network(self, args):
        """Create a new network."""
        name = args.strip()
        if not name:
            print("You have to specify a name")
            return
        try:
            self._state.create_network(name)
        except Exception as e:
            print(e)

    def do_refresh_networks(self, args):
        try:
            self._state.refresh_networks()
        except Exception as e:
            print(e)

    def do_start(self, args):
        """Mount all infinit networks."""
        try:
            self._state.launch_watchdog()
        except Exception as e:
            print(e)

    def do_stop(self, args):
        try:
            self._state.stop_watchdog()
        except Exception as e:
            print(e)

    def do_logout(self, args):
        try:
            self._state.logout()
        except Exception as e:
            print(e)

    def do_invite(self, args):
        """
        invite a user to join a network.
        usage: invite user network
        """
        if len(args.split()) != 2:
            print("Wrong arguments")
            return

        user, network = args.split()
        network_id = None
        for id_ in self._state.networks():
            if id_ == network or self._state.network_name(id_) == network:
                network_id = id_
                break

        if network_id is None:
            print("Cannot find any network with the name or id '%s'" % network)
            return

        try:
            self._state.network_add_user(network_id, user)
        except Exception as e:
            print(e)

    def do_create_device(self, args=""):
        """Create local device with specified name or your host name"""
        dev_name = args.strip()
        if not dev_name:
            import socket
            dev_name = socket.gethostname().strip()
        try:
            self._state.set_device_name(dev_name)
        except Exception as e:
            print(e)

    def default(self, line):
        if line == 'EOF':
            print()
            raise KeyboardInterrupt()
        print("Command not found:", line)

def start_shell(state, args):
    shell = InfinitShell(state, args)

    if not state.has_device:
        if args.action == 'shell':
            print("No local device found, try 'create_device' command")
        else:
            import socket
            default_dev_name = socket.gethostname().strip()
            dev_name = input("Computer name (defaults to '%s'): " % default_dev_name).strip()
            if not dev_name:
                dev_name = default_dev_name
            shell.do_create_device(dev_name)

    if args.action == 'shell':
        shell.cmdloop(SHELL_INTRO)
    else:
        getattr(shell, 'do_' + args.action)('')

def re_input(prompt, pattern=".+", regexp=None, errmsg="Input is not valid", default=None):
    if default is not None:
        prompt += " (defaults to %s)" % default
    prompt += ': '
    while True:
        res = input(prompt).strip()
        if not res and default:
            res = default
            break
        if regexp is not None:
            if regexp.match(res):
                break
        elif re.match('^' + pattern + '$', res):
            break
        print(errmsg)
    return res

def register(state):
    fullname = re_input("Fullname", pattern='[\w ]{3,64}')
    email = re_input("Email", regexp=EMAIL_REGEXP)
    while True:
        password = getpass.getpass("password: ")
        password2 = getpass.getpass("confirm password: ")
        if password != password2:
            print("Passwords don't match!")
        elif len(password) < 4:
            print("Password too short")
        else:
            break
    import socket
    dev_name = re_input(
        "Computer name",
        pattern="[\w ]{3,64}",
        default=socket.gethostname().strip(),
    )
    activation_code = re_input("Activation code")
    state.register(fullname, email, password, dev_name, activation_code)

def login(state):
    email = re_input("email", regexp=EMAIL_REGEXP)
    while True:
        password = getpass.getpass("password: ").strip()
        if password:
            break
        print("empty password not allowed")
    state.login(email, password)

def update_binaries():
    # Prepare directories
    if not os.path.exists(INFINIT_HOME):
        if INFINIT_HOME == INFINIT_DEFAULT_HOME:
            os.makedirs(INFINIT_HOME)
        else:
            raise Exception("The specified home directory does not exists !")

    for dir_ in ['bin', 'lib', 'python']:
        path = os.path.join(INFINIT_HOME, dir_)
        if not os.path.exists(path):
            os.makedirs(path)

    from urllib.request import urlopen
    import xml.etree.cElementTree as et
    import hashlib

    # Download manifest.
    with urlopen(MANIFEST_URI) as req:
        root = et.fromstring(req.read())

    # Extract xml.
    binaries = []
    for el in root:
        binaries.append(dict(el.items()))

    total_size = int(dict(root.items())['size'])

    # Update binaries.
    for binary in binaries:
        url = "http://download.infinit.im/linux64/%s" % binary['path']
        dst_path = os.path.join(INFINIT_HOME, binary['path'])

        # Check if the binary is up to date.
        if os.path.exists(dst_path):
            md5 = hashlib.md5()
            with open(dst_path, 'rb') as dst:
                print("Check %s" % binary['path'])
                data = dst.read(4096)
                while data:
                    md5.update(data)
                    data = dst.read(4096)
            if md5.hexdigest() == binary['md5sum']:
                continue

        # Otherwise we download it.
        with open(dst_path, 'wb') as dst:
            with urlopen(url) as src:
                print("Downloading %s" % binary['path'])
                data = src.read(4096)
                while data:
                    dst.write(data)
                    data = src.read(4096)
        os.chmod(dst_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IEXEC)


def main():
    args = parser.parse_args()

    if not args.no_update:
        update_binaries()

    file_dir = os.path.abspath(os.path.dirname(__file__))
    sys.path = [
        os.path.join(file_dir, '..', 'gap', 'python'),
        os.path.join(file_dir, '..', 'python'),
    ] + sys.path

    import gap
    state = gap.State()
    if args.register:
        print("Registering to infinit:")
        register(state)
    else:
        print("Authentication required (if you don't have an account, try -r)")
        login(state)

    start_shell(state, args)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
