#!/usr/bin/env python3
# -*- encoding: utf-8 -*-


"""
Infinit launcher for unices.
"""

import argparse
import cmd
import getpass
import os
import re
import stat
import sys

# Poll thread
import time
import threading


try:
    import readline
except:
    try:
        import pyreadline as readline
    except:
        print('Warning: you should install python readline package.')
try:
    import rlcompleter
    if sys.platform == 'darwin':
        readline.parse_and_bind("bind ^I rl_complete")
    else:
        readline.parse_and_bind("tab: complete")
except:
    pass

INFINIT_DEFAULT_HOME = os.path.join(
    os.path.expanduser('~'), '.infinit'
)

INFINIT_HOME = os.environ.get('INFINIT_HOME', INFINIT_DEFAULT_HOME)

if 'darwin' in sys.platform.lower():
    INFINIT_PLATFORM = 'macosx'
elif 'linux' in sys.platform.lower():
    INFINIT_PLATFORM = 'linux'
else:
    raise Exception("Unsupported platform")

if sys.maxsize > 2**32:
    INFINIT_PLATFORM += '64'
else:
    INFINIT_PLATFORM += '32'

MANIFEST_URI = "http://download.infinit.im/%s/manifest.xml" % INFINIT_PLATFORM

SHELL_INTRO = """
Welcome to the infinit shell (type help for a list of commands).
"""

EMAIL_REGEXP = re.compile(
    r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*"  # dot-atom
    r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-011\013\014\016-\177])*"' # quoted-string
    r')@(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?$',
    re.IGNORECASE
)

parser = argparse.ArgumentParser(description="Infinit launcher")

parser.add_argument(
    'action',
    choices=['register', 'start', 'stop', 'shell'],
    nargs='+',
    help="Action done once logged in",
)

parser.add_argument(
    '--no-update', '-n',
    help="Skip the update process",
    action="store_true",
)

parser.add_argument(
    '--debug', '-d',
    help="Enable debug mode",
    action="store_true",
)

def make_simple_argument_parser(prog=None,
                                description=None,
                                add_help=False,
                                args=None):
    parser = argparse.ArgumentParser(prog=prog,
                                     description=description,
                                     add_help=add_help)
    def raise_parser_exception(self, status=None, message=""):
        raise Exception(message)
    parser.exit = raise_parser_exception
    for arg in args:
        flags = arg.pop('flags')
        if not (isinstance(flags, list) or isinstance(flags, tuple)):
            flags = (flags,)
        parser.add_argument(*flags, **arg)
    return parser

class InfinitShell(cmd.Cmd):
    def __init__(self, state, args):
        self._state = state
        self._args = args
        self.prompt = state.email + '$ '
        super(InfinitShell, self).__init__()

    def default(self, line):
        if line == 'EOF':
            print('exit')
            raise KeyboardInterrupt()
        print("Command not found:", line)

    def emptyline(self):
        pass

    def _get_args(self, parser, line):
        try:
            return parser.parse_args(line.strip().split())
        except Exception as e:
            print(str(e).strip())

    ###########################################################################
    # Retreive networks.

    _networks_argument_parser = make_simple_argument_parser(
        prog = "networks",
        description = "Print all networks",
        args = [],
    )

    def do_networks(self, line):
        """Print networks."""
        args = self._get_args(self._networks_argument_parser, line)
        try:
            networks = self._state.networks()
            for network_id in networks:
                print(self._state.network_name(network_id),
                      '(%s)' % network_id)
                mnt = None
                try: mnt = self._state.network_mount_point(network_id)
                except: pass
                print('\t- mount point:', mnt)
        except Exception as e:
            print(e)

    def help_networks(self):
        self._networks_argument_parser.print_help()

    ###########################################################################
    # Retreive networks.

    _create_network_argument_parser = make_simple_argument_parser(
        prog = "create_network",
        description = "Create a new network",
        args = [
            {
                'flags': 'name',
                'help': "The network name",
            },
        ]
    )

    def help_create_network(self):
        self._create_network_argument_parser.print_help()

    def do_create_network(self, line):
        args = self._get_args(self._create_network_argument_parser, line)
        if not args:
            return
        try:
            self._state.create_network(args.name)
        except Exception as e:
            print(e)

    ###########################################################################
    # Refresh networks.

    def do_refresh_networks(self, args):
        """Refresh networks."""
        try:
            self._state.refresh_networks()
        except Exception as e:
            print(e)

    ###########################################################################
    # Start infinit.

    def do_start(self, args):
        """Mount all infinit networks."""
        try:
            self._state.launch_watchdog()
        except Exception as e:
            print(e)

    ###########################################################################
    # Stop infinit.

    def do_stop(self, args):
        try:
            self._state.stop_watchdog()
        except Exception as e:
            print(e)


    ###########################################################################
    # Log out from infinit.

    def do_logout(self, args):
        try:
            self._state.logout()
        except Exception as e:
            print(e)

    ###########################################################################
    # Invite a user to a network.

    _invite_argument_parser = make_simple_argument_parser(
        prog = "invite",
        description = "Invite a user to join one of your networks",
        args = [
            {
                'flags': 'user',
                'help': 'email of the user to invite (can also be its id).',
            },
            {
                'flags': 'network',
                'help': 'The network name (or id) you want to share.',
            },
        ],
    )

    def help_invite(self):
        self._invite_argument_parser.print_help()

    def do_invite(self, line):
        args = self._get_args(self._invite_argument_parser, line)
        if not args:
            return

        network_id = None
        for id_ in self._state.networks():
            if id_ == args.network or \
               self._state.network_name(id_) == args.network:
                network_id = id_
                break

        if network_id is None:
            print("Cannot find any network with the name or id '%s'" % args.network)
            return

        try:
            self._state.network_add_user(network_id, args.user)
        except Exception as e:
            print(e)

    def do_create_device(self, args=""):
        """Create local device with specified name or your host name"""
        dev_name = args.strip()
        if not dev_name:
            import socket
            dev_name = socket.gethostname().strip()
        try:
            self._state.set_device_name(dev_name)
        except Exception as e:
            print(e)

    ###########################################################################
    # Send files.
    _sendfiles_argument_parser = make_simple_argument_parser(
        prog = "sendfiles",
        description = "Invite a user to exchange a file. If the user doesn't exist, invite him to infinit.",
        args = [
            {
                'flags': 'user',
                'help': 'email of the user to invite (can also be its id).',
            },
            {
                'flags': 'files',
                'action': 'append',
                'help': 'files to send.',
            }
        ],
    )

    def help_sendfiles(self):
        self._sendfiles_argument_parser.print_help()

    def do_sendfiles(self, line):
        args = self._get_args(self._sendfiles_argument_parser, line)
        if not args:
            return

        recipient = args.user

        try:
            self._state.send_files(recipient, files)
        except Exception as e:
            print(e)

    # def complete_sendfiles(self, text, line, begidx, endidx):
    #     # XXX: Finish completion.
    #     print(text, line, begidx, endidx, sep="|")
    #     return []

    ###########################################################################
    # Default.
    def default(self, line):
        if line == 'EOF':
            print()
            raise KeyboardInterrupt()
        print("Command not found:", line)

def start_shell(state, args):
    shell = InfinitShell(state, args)

    if not state.has_device:
        if args.action == 'shell':
            print("No local device found, try 'create_device' command")
        else:
            import socket
            default_dev_name = socket.gethostname().strip()
            dev_name = input("Computer name (defaults to '%s'): " % default_dev_name).strip()
            if not dev_name:
                dev_name = default_dev_name
            shell.do_create_device(dev_name)

    if 'shell' in args.action:
        do_shell = True
        args.action.remove('shell')
    else:
        do_shell = False

    for action in set(args.action):
        getattr(shell, 'do_' + action)('')

    if do_shell:
        shell.cmdloop(SHELL_INTRO)

def re_input(prompt, pattern=".+", regexp=None, errmsg="Input is not valid", default=None):
    if default is not None:
        prompt += " (defaults to %s)" % default
    prompt += ': '
    while True:
        res = input(prompt).strip()
        if not res and default:
            res = default
            break
        if regexp is not None:
            if regexp.match(res):
                break
        elif re.match('^' + pattern + '$', res):
            break
        print(errmsg)
    return res

def register(state):
    import socket
    fullname = re_input("Fullname", pattern='[\w ]{3,64}')
    email = re_input("Email", regexp=EMAIL_REGEXP)
    while True:
        password = getpass.getpass("password: ")
        password2 = getpass.getpass("confirm password: ")
        if password != password2:
            print("Passwords don't match!")
            continue
        elif len(password) < 4:
            print("Password too short")
            continue
        dev_name = re_input(
          "Computer name",
          pattern="[\w ]{3,64}",
          default=socket.gethostname().strip(),
        )
        activation_code = re_input("Activation code")
        try:
          state.register(fullname, email, password, dev_name, activation_code)
        except:
          pass
        else:
          break

def login(state):
    email=None
    while True:
        email = re_input("email", regexp=EMAIL_REGEXP, default=email)
        password = getpass.getpass("password: ").strip()
        if not password:
            print("empty password not allowed")
            continue
        try:
            state.login(email, password)
        except Exception as e:
            print("Cannot login:", e)
        else:
            break

def update_binaries():
    # Prepare directories
    if not os.path.exists(INFINIT_HOME):
        if INFINIT_HOME == INFINIT_DEFAULT_HOME:
            os.makedirs(INFINIT_HOME)
        else:
            raise Exception("The specified home directory does not exists !")

    for dir_ in ['bin', 'lib', 'python']:
        path = os.path.join(INFINIT_HOME, dir_)
        if not os.path.exists(path):
            os.makedirs(path)

    from urllib.request import urlopen
    import xml.etree.cElementTree as et
    import hashlib

    # Download manifest.
    with urlopen(MANIFEST_URI) as req:
        root = et.fromstring(req.read())

    # Extract xml.
    binaries = []
    for el in root:
        binaries.append(dict(el.items()))

    total_size = int(dict(root.items())['size'])

    # Update binaries.
    for binary in binaries:
        url = "http://download.infinit.im/%s/%s" % (INFINIT_PLATFORM, binary['path'])
        dst_path = os.path.join(INFINIT_HOME, binary['path'])

        # Check if the binary is up to date.
        if os.path.exists(dst_path):
            md5 = hashlib.md5()
            with open(dst_path, 'rb') as dst:
                print("Check %s" % binary['path'])
                data = dst.read(4096)
                while data:
                    md5.update(data)
                    data = dst.read(4096)
            if md5.hexdigest() == binary['md5sum']:
                continue
        try:
            os.makedirs(os.path.dirname(dst_path))
        except:
            pass

        # Otherwise we download it.
        with open(dst_path, 'wb') as dst:
            with urlopen(url) as src:
                print("Downloading %s" % binary['path'])
                data = src.read(4096)
                while data:
                    dst.write(data)
                    data = src.read(4096)
        os.chmod(dst_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IEXEC)


def main():
    args = parser.parse_args()

    if not args.no_update:
        update_binaries()

    file_dir = os.path.abspath(os.path.dirname(__file__))
    sys.path = [
        os.path.join(file_dir, '..', 'gap', 'python'),
        os.path.join(INFINIT_HOME, 'python'),
        os.path.join(file_dir, '..', 'python'),
    ] + sys.path

    import gap
    state = gap.State()
    if args.debug:
        state.enable_debug()
    print("actions", args.action)
    if 'register' in args.action:
        print("Registering to infinit:")
        args.action.remove('register')
        register(state)
    else:
        print("Authentication required (if you don't have an account, try -r)")
        login(state)

    state.OnTransaction(_IncommingFileTransferHandler)
    state.OnTransactionStatus(_FileTransferStatusHandler)
    state.OnMessage(_MessageHandler)
    thread = PollThread(state)
    thread.start()
    state.connect()
    start_shell(state, args)

def _IncommingFileTransferHandler(transfer):
    username = state.user_fullname(transfer.sender_id)
    print("_IncommingFileTransferHandler:", username)
    #state.answer_transaction(transfer.transaction_id, answer)

def _FileTransferStatusHandler(status):
    print("_FileTransferStatusHandler")

def _MessageHandler(message):
    print("_MessageHandler")

class PollThread (threading.Thread):
    close = False

    def __init__(self, state):
        super(PollThread, self).__init__()
        self.state = state

    def run (self):
        self.bite = False
        while True:
            time.sleep(0.5)
            self.state.poll()
            if self.close == True:
                return

    def stop(self):
        self.close = True

if __name__ == '__main__':
    thread = 0
    try:
        main()
    except KeyboardInterrupt:
        if thread:
            thread.close()
            time.sleep(0.05)
        pass
