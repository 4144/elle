#!/usr/bin/env python3
# -*- encoding: utf-8 -*-


"""
Infinit launcher for linux.
"""

import argparse
import cmd
import getpass
import os
import stat
import sys

INFINIT_DEFAULT_HOME = os.path.join(
    os.path.expanduser('~'), '.config', 'infinit'
)

INFINIT_HOME = os.environ.get('INFINIT_HOME', INFINIT_DEFAULT_HOME)

MANIFEST_URI = "http://download.infinit.im/linux64/manifest.xml"

SHELL_INTRO = """
Welcome to the infinit shell (type help for a list of commands).
"""

parser = argparse.ArgumentParser(description="Infinit launcher")

parser.add_argument(
    '--register',
    '-r',
    help="Register instead of log in",
    action="store_true"
)

parser.add_argument(
    'action',
    choices=['start', 'stop', 'restart', 'shell'],
    default='start',
    nargs='?',
    help="Action done once logged in",
)

parser.add_argument(
    '--no-update',
    help="Skip the update process",
    action="store_true",
)

class InfinitShell(cmd.Cmd):
    def __init__(self, state, args):
        self._state = state
        self._args = args
        self.prompt = state.email + '$ '
        super(InfinitShell, self).__init__()

    def do_networks(self, args):
        """Print networks."""
        networks = self._state.networks()
        for network in networks:
            print(network)

    def do_create_network(self, args):
        """Create a new network."""
        name = args.strip()
        if not name:
            print("You have to specify a name")
            return
        self._state.create_network(name)

    def do_refresh_networks(self, args):
        self._state.refresh_networks()

    def do_start(self, args):
        """Mount all infinit networks."""
        self._state.launch_watchdog()

    def do_stop(self, args):
        self._state.stop_watchdog()

    def do_create_device(self, args=""):
        """Create local device with specified name or your host name"""
        dev_name = args.strip()
        if not dev_name:
            import socket
            dev_name = socket.gethostname().strip()
        self._state.set_device_name(dev_name)

    def default(self, line):
        if line == 'EOF':
            print()
            raise KeyboardInterrupt()
        print("Command not found:", line)

def start_shell(state, args):
    shell = InfinitShell(state, args)

    if not state.has_device:
        if args.action == 'shell':
            print("No local device found, try 'create_device' command")
        else:
            import socket
            default_dev_name = socket.gethostname().strip()
            dev_name = input("Computer name (defaults to '%s'): " % default_dev_name).strip()
            if not dev_name:
                dev_name = default_dev_name
            shell.do_create_device(dev_name)

    if args.action == 'shell':
        shell.cmdloop(SHELL_INTRO)
    else:
        getattr(shell, 'do_' + args.action)('')

def register(state):
    fullname = input("Enter your fullname: ").strip()
    email = input("email: ").strip()
    while True:
        password = getpass.getpass("password: ")
        password2 = getpass.getpass("confirm password: ")
        if password != password2:
            print("Passwords don't match!")
        elif len(password) < 4:
            print("Password too short")
        else:
            break


    state.register(fullname, email, password, dev_name)

def login(state):
    email = input("email: ").strip()
    password = getpass.getpass("password: ")
    state.login(email, password)

def update_binaries():
    # Prepare directories
    if not os.path.exists(INFINIT_HOME):
        if INFINIT_HOME == INFINIT_DEFAULT_HOME:
            os.makedirs(INFINIT_HOME)
        else:
            raise Exception("The specified home directory does not exists !")

    for dir_ in ['bin', 'lib', 'python']:
        path = os.path.join(INFINIT_HOME, dir_)
        if not os.path.exists(path):
            os.makedirs(path)

    from urllib.request import urlopen
    import xml.etree.cElementTree as et
    import hashlib

    # Download manifest.
    with urlopen(MANIFEST_URI) as req:
        root = et.fromstring(req.read())

    # Extract xml.
    binaries = []
    for el in root:
        binaries.append(dict(el.items()))

    total_size = int(dict(root.items())['size'])

    # Update binaries.
    for binary in binaries:
        url = "http://download.infinit.im/linux64/%s" % binary['path']
        dst_path = os.path.join(INFINIT_HOME, binary['path'])

        # Check if the binary is up to date.
        if os.path.exists(dst_path):
            md5 = hashlib.md5()
            with open(dst_path, 'rb') as dst:
                print("Check %s" % binary['path'])
                data = dst.read(4096)
                while data:
                    md5.update(data)
                    data = dst.read(4096)
            if md5.hexdigest() == binary['md5sum']:
                continue

        # Otherwise we download it.
        with open(dst_path, 'wb') as dst:
            with urlopen(url) as src:
                print("Downloading %s" % binary['path'])
                data = src.read(4096)
                while data:
                    dst.write(data)
                    data = src.read(4096)
        os.chmod(dst_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IEXEC)


def main(state):
    args = parser.parse_args()

    if not args.no_update:
        update_binaries()

    if args.register:
        print("Registering to infinit:")
        register(state)
    else:
        print("Authentication required (if you don't have an account, try -r)")
        login(state)

    start_shell(state, args)

if __name__ == '__main__':
    file_dir = os.path.abspath(os.path.dirname(__file__))
    sys.path = [
        os.path.join(file_dir, '..', 'gap', 'python'),
        os.path.join(file_dir, '..', 'python'),
    ] + sys.path

    import gap
    state = gap.State()
    try:
        main(state)
    except KeyboardInterrupt:
        del state
